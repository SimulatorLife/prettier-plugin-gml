import { isObjectOrFunction } from "./object.js";
import { getNonEmptyString } from "./string.js";

const DEFAULT_ABORT_MESSAGE = "Operation aborted.";

type AbortErrorMetadata = Record<PropertyKey, unknown> & {
    name?: string;
    message?: string;
    stack?: string;
    code?: string | number;
};

type AbortErrorLike = Error | AbortErrorMetadata;

type AbortSignalEventListener = (event?: { type?: string }) => unknown;

export interface AbortSignalLike {
    readonly aborted: boolean;
    readonly reason?: unknown;
    onabort?: AbortSignalEventListener | null;
    addEventListener?: (
        type: string,
        listener: AbortSignalEventListener,
        options?: boolean | { once?: boolean }
    ) => void;
    removeEventListener?: (
        type: string,
        listener: AbortSignalEventListener
    ) => void;
    dispatchEvent?: (event: { type?: string }) => boolean;
    throwIfAborted?: () => void;
}

const ERROR_METADATA_KEYS = ["message", "name", "stack"];

const abortErrorBrand = new WeakSet<AbortErrorLike>();

function shouldReuseAbortReason(value: unknown): value is AbortErrorLike {
    if (!isObjectOrFunction(value)) {
        return false;
    }

    const candidate = value as Record<PropertyKey, unknown>;
    return (
        ERROR_METADATA_KEYS.some(
            (key) => candidate[key] !== null && candidate[key] !== undefined
        ) || "cause" in candidate
    );
}

function toAbortMessage(value) {
    if (typeof value === "string") {
        return value;
    }

    // Treat both `null` and `undefined` as absent reasons so callers that
    // omit a reason use the provided fallback message instead of the
    // stringified value "undefined".
    if (value == null) {
        return null;
    }

    try {
        return String(value);
    } catch {
        return null;
    }
}

function brandAbortError(error: AbortErrorLike, fallbackMessage: string) {
    if (!getNonEmptyString(error.name)) {
        error.name = "AbortError";
    }

    if (!getNonEmptyString(error.message)) {
        error.message = fallbackMessage;
    }

    if (isObjectOrFunction(error)) {
        abortErrorBrand.add(error);
    }

    return error;
}

function normalizeAbortError(
    reason: unknown,
    fallbackMessage: string
): AbortErrorLike {
    const fallback =
        getNonEmptyString(fallbackMessage) ?? DEFAULT_ABORT_MESSAGE;
    const error: AbortErrorLike = shouldReuseAbortReason(reason)
        ? reason
        : new Error(getNonEmptyString(toAbortMessage(reason)) ?? fallback);

    return brandAbortError(error, fallback);
}

function ensureAbortError(error: AbortErrorLike): Error {
    if (error instanceof Error) {
        return error;
    }

    const normalizedMessage =
        getNonEmptyString(error.message) ?? DEFAULT_ABORT_MESSAGE;
    const normalized = new Error(normalizedMessage);

    if (isObjectOrFunction(error)) {
        Object.assign(normalized, error);
    }

    return normalized;
}

/**
 * Convert an `AbortSignal` that has been triggered into an `Error` instance.
 *
 * Centralizes the guard logic shared by the parser and CLI so call sites can
 * consistently surface `AbortError` instances while preserving any user-
 * supplied reason text. Non-aborted signals yield `null`, allowing callers to
 * short-circuit without additional branching.
 *
 * @param {AbortSignal | null | undefined} signal Signal to inspect for an
 *        aborted state.
 * @param {string | null} [fallbackMessage] Optional message used when the
 *        signal does not provide a reason value.
 * @returns {Error | null} `AbortError` compatible instance when aborted;
 *          otherwise `null`.
 */
export function createAbortError(
    signal: AbortSignalLike | null | undefined,
    fallbackMessage: string = DEFAULT_ABORT_MESSAGE
): AbortErrorLike | null {
    if (!signal || signal.aborted !== true) {
        return null;
    }

    return normalizeAbortError(signal.reason, fallbackMessage);
}

/**
 * Determine whether a value corresponds to an `AbortError` generated by this
 * module. The guard accepts native `AbortError` instances as well as errors
 * produced through {@link createAbortError} and {@link throwIfAborted}, allowing
 * consumers to handle cancellation branches without relying on brittle string
 * comparisons.
 *
 * @param {unknown} value Potential error object to inspect.
 * @returns {boolean} `true` when the value is a branded abort error; otherwise
 *          `false`.
 */
const ABORT_ERROR_NAME = "aborterror";
const ABORT_ERROR_STRING_CODE = "ABORT_ERR";
const DOM_EXCEPTION_ABORT_ERR_CODE =
    typeof DOMException === "function" &&
    typeof DOMException.ABORT_ERR === "number"
        ? DOMException.ABORT_ERR
        : null;

export function isAbortError(value: unknown): boolean {
    if (value === null) {
        return false;
    }

    if (!isObjectOrFunction(value)) {
        return false;
    }

    const candidate = value as AbortErrorLike;

    if (abortErrorBrand.has(candidate)) {
        return true;
    }

    const name = getNonEmptyString(
        /** @type {{ name?: unknown }} */ (candidate as { name?: unknown }).name
    );
    if (name?.toLowerCase() === ABORT_ERROR_NAME) {
        return true;
    }

    const code = (candidate as { code?: unknown }).code;

    if (typeof code === "string") {
        return code.toUpperCase() === ABORT_ERROR_STRING_CODE;
    }

    if (
        typeof code === "number" &&
        DOM_EXCEPTION_ABORT_ERR_CODE !== null &&
        code === DOM_EXCEPTION_ABORT_ERR_CODE
    ) {
        return true;
    }

    return false;
}

/**
 * Throw an `AbortError` when the provided signal has been cancelled.
 *
 * Mirrors the semantics of {@link createAbortError} while providing a
 * convenience wrapper that matches the rest of the shared utilities.
 *
 * @param {AbortSignal | null | undefined} signal Signal guarding the work.
 * @param {string | null} [fallbackMessage] Optional replacement message when
 *        the signal omits a reason.
 * @returns {void}
 */
export function throwIfAborted(
    signal: AbortSignalLike | null | undefined,
    fallbackMessage?: string | null
) {
    const error = createAbortError(
        signal,
        fallbackMessage ?? DEFAULT_ABORT_MESSAGE
    );
    if (error) {
        throw ensureAbortError(error);
    }
}

/**
 * Construct a reusable guard around an {@link AbortSignal} extracted from an
 * options bag. The guard normalizes the signal once and exposes a convenience
 * callback that can be reused at every async boundary to surface a consistent
 * {@link AbortError} when cancellation occurs.
 *
 * The helper mirrors the pattern previously implemented in the project index
 * layer where callers repeatedly pulled the signal from `options`, checked for
 * cancellation, and forwarded the same fallback message. Centralizing the
 * guard alongside the rest of the abort helpers keeps the behaviour consistent
 * across feature areas while making the utility discoverable to other
 * long-running workflows.
 *
 * @param {unknown} options Candidate options object that may expose a signal.
 * @param {{
 *     key?: string | number | symbol,
 *     fallbackMessage?: string | null
 * }} [config]
 * @returns {{ signal: AbortSignal | null, ensureNotAborted(this: void): void }}
 *          Guard exposing the normalized signal and a checkpoint callback.
 */
type AbortConfig = {
    key?: string | number | symbol;
    fallbackMessage?: string | null;
};

export function createAbortGuard(
    options: unknown,
    { key, fallbackMessage }: AbortConfig = {}
): {
    signal: AbortSignalLike | null;
    ensureNotAborted(this: void): void;
} {
    const signal = resolveAbortSignalFromOptions(options, {
        key,
        fallbackMessage
    });

    const ensureNotAborted = () => throwIfAborted(signal, fallbackMessage);

    return { signal, ensureNotAborted };
}

function isAbortSignalLike(value: unknown): value is AbortSignalLike {
    return (
        value !== null &&
        (typeof value === "object" || typeof value === "function") &&
        typeof (value as AbortSignalLike).aborted === "boolean"
    );
}

/**
 * Extract an `AbortSignal` from an options bag while ensuring it has not
 * already been cancelled. This consolidates the repetitive guard logic spread
 * throughout the project index helpers where every entry point previously
 * reimplemented the same `options?.signal ?? null` pattern.
 *
 * Callers receive either the validated signal instance or `null` when the
 * options bag does not expose a usable signal. Any pre-aborted signals raise an
 * `AbortError` using the same fallback semantics as {@link throwIfAborted} to
 * keep error reporting consistent.
 *
 * @param {unknown} options Candidate options object that may carry a signal.
 * @param {{
 *     key?: string | number | symbol,
 *     fallbackMessage?: string | null | undefined
 * }} [config]
 * @param {string | number | symbol} [config.key="signal"] Property name used
 *        to retrieve the signal from {@link options}.
 * @param {string | null | undefined} [config.fallbackMessage] Optional message
 *        forwarded when surfacing an `AbortError` for an already-cancelled
 *        signal.
 * @returns {AbortSignal | null} Normalized signal instance or `null` when the
 *          options object does not supply one.
 */
export function resolveAbortSignalFromOptions(
    options: unknown,
    { key = "signal", fallbackMessage }: AbortConfig = {}
): AbortSignalLike | null {
    if (!isObjectOrFunction(options)) {
        return null;
    }

    const candidate =
        /** @type {Record<PropertyKey, unknown>} */ options[key] ?? null;
    if (!isAbortSignalLike(candidate)) {
        return null;
    }

    throwIfAborted(candidate, fallbackMessage);
    return candidate;
}
