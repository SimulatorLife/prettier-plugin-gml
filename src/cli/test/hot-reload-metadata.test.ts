/**
 * Test patch metadata flow through the hot reload pipeline.
 *
 * Validates that patches generated by the transpiler include metadata
 * with timestamps and source paths, and that this metadata flows through
 * to the WebSocket clients for end-to-end timing analysis.
 */

import assert from "node:assert";
import { mkdir, rm, writeFile } from "node:fs/promises";
import path from "node:path";
import { after, before, describe, it } from "node:test";

import { runWatchCommand } from "../src/commands/watch.js";
import { findAvailablePort } from "./test-helpers/free-port.js";
import { connectToHotReloadWebSocket, type WebSocketPatchStream } from "./test-helpers/websocket-client.js";

void describe("Hot reload patch metadata", () => {
    let testDir: string;
    let testFile: string;
    let websocketClient: WebSocketPatchStream | null = null;

    before(async () => {
        testDir = path.join(process.cwd(), "tmp", `test-metadata-${Date.now()}`);
        await mkdir(testDir, { recursive: true });
        testFile = path.join(testDir, "metadata_script.gml");
        await writeFile(testFile, "// Initial content\nvar test_value = 42;", "utf8");
        websocketClient = null;
    });

    after(async () => {
        if (websocketClient) {
            await websocketClient.disconnect();
        }
        if (testDir) {
            await rm(testDir, { recursive: true, force: true });
        }
    });

    void it("should include metadata with timestamp in generated patches", async () => {
        const websocketPort = await findAvailablePort();
        const abortController = new AbortController();

        const watchPromise = runWatchCommand(testDir, {
            extensions: [".gml"],
            verbose: false,
            websocketPort,
            websocketHost: "127.0.0.1",
            runtimeServer: false,
            statusServer: false,
            abortSignal: abortController.signal
        });

        const receivedPatches = await (async () => {
            try {
                websocketClient = await connectToHotReloadWebSocket(`ws://127.0.0.1:${websocketPort}`, {
                    connectionTimeoutMs: 1200,
                    retryIntervalMs: 25
                });

                // Modify the file to trigger a patch
                await writeFile(testFile, "// Updated content\nvar test_value = 100;", "utf8");

                return await websocketClient.waitForPatches({ timeoutMs: 1500 });
            } finally {
                abortController.abort();

                if (websocketClient) {
                    await websocketClient.disconnect();
                }

                try {
                    await watchPromise;
                } catch {
                    // Expected when aborting
                }
            }
        })();

        assert.ok(receivedPatches.length > 0, "Should receive at least one patch");

        const patch = receivedPatches[0] as Record<string, unknown>;

        // Verify patch structure
        assert.strictEqual(patch.kind, "script", "Patch should be a script");
        assert.ok(patch.id, "Patch should have an ID");
        assert.ok(patch.js_body, "Patch should have JavaScript body");

        // Verify metadata exists
        assert.ok(patch.metadata, "Patch should include metadata");
        const metadata = patch.metadata as Record<string, unknown>;

        // Verify timestamp exists and is recent
        assert.ok(metadata.timestamp, "Metadata should include timestamp");
        assert.strictEqual(typeof metadata.timestamp, "number", "Timestamp should be a number");
        const timestamp = metadata.timestamp as number;
        const now = Date.now();
        const age = now - timestamp;
        assert.ok(age >= 0 && age < 10_000, `Timestamp should be recent (age: ${age}ms, expected < 10000ms)`);

        // Verify source path exists
        assert.ok(metadata.sourcePath, "Metadata should include sourcePath");
        assert.strictEqual(typeof metadata.sourcePath, "string", "Source path should be a string");
        assert.ok(
            (metadata.sourcePath as string).includes("metadata_script.gml"),
            "Source path should reference the test file"
        );
    });
});
