/**
 * Test patch metadata flow through the hot reload pipeline.
 *
 * Validates that patches generated by the transpiler include metadata
 * with timestamps and source paths, and that this metadata flows through
 * to the WebSocket clients for end-to-end timing analysis.
 */

import { describe, it, before, after } from "node:test";
import assert from "node:assert";
import { writeFile, mkdir, rm } from "node:fs/promises";
import path from "node:path";
import WebSocket from "ws";

import { runWatchCommand } from "../src/commands/watch.js";
import { findAvailablePort } from "./test-helpers/free-port.js";

void describe("Hot reload patch metadata", () => {
    let testDir: string;
    let testFile: string;
    let websocketClient;

    before(async () => {
        testDir = path.join(process.cwd(), "tmp", `test-metadata-${Date.now()}`);
        await mkdir(testDir, { recursive: true });
        testFile = path.join(testDir, "metadata_script.gml");
        await writeFile(testFile, "// Initial content\nvar test_value = 42;", "utf8");
        websocketClient = undefined;
    });

    after(async () => {
        if (websocketClient) {
            await new Promise<void>((resolve) => {
                try {
                    websocketClient?.once("close", () => resolve());
                    websocketClient?.close();
                } catch {
                    resolve();
                }
            });
        }
        if (testDir) {
            await rm(testDir, { recursive: true, force: true });
        }
    });

    void it("should include metadata with timestamp in generated patches", async () => {
        const websocketPort = await findAvailablePort();
        const abortController = new AbortController();

        const watchPromise = runWatchCommand(testDir, {
            extensions: [".gml"],
            verbose: false,
            websocketPort,
            websocketHost: "127.0.0.1",
            runtimeServer: false,
            statusServer: false,
            abortSignal: abortController.signal
        });

        // Wait for watch command to initialize
        await new Promise((resolve) => setTimeout(resolve, 1000));

        const receivedPatches: Array<unknown> = [];

        // Connect WebSocket client and wait for patch
        await new Promise<void>((resolve, reject) => {
            websocketClient = new WebSocket(`ws://127.0.0.1:${websocketPort}`);

            websocketClient.on("open", async () => {
                try {
                    // Modify the file to trigger a patch
                    await writeFile(testFile, "// Updated content\nvar test_value = 100;", "utf8");
                } catch (error) {
                    reject(new Error(error instanceof Error ? error.message : String(error)));
                }
            });

            websocketClient.on("message", (data) => {
                try {
                    const patch = JSON.parse(data.toString());
                    receivedPatches.push(patch);

                    // Resolve after receiving first patch
                    if (receivedPatches.length === 1) {
                        resolve();
                    }
                } catch (error) {
                    reject(error instanceof Error ? error : new Error(String(error)));
                }
            });

            websocketClient.on("error", (error) => {
                reject(new Error(error instanceof Error ? error.message : String(error)));
            });

            // Timeout after 5 seconds
            setTimeout(() => {
                reject(new Error("Timeout waiting for patch"));
            }, 5000);
        });

        abortController.abort();

        try {
            await watchPromise;
        } catch {
            // Expected when aborting
        }

        assert.ok(receivedPatches.length > 0, "Should receive at least one patch");

        const patch = receivedPatches[0] as Record<string, unknown>;

        // Verify patch structure
        assert.strictEqual(patch.kind, "script", "Patch should be a script");
        assert.ok(patch.id, "Patch should have an ID");
        assert.ok(patch.js_body, "Patch should have JavaScript body");

        // Verify metadata exists
        assert.ok(patch.metadata, "Patch should include metadata");
        const metadata = patch.metadata as Record<string, unknown>;

        // Verify timestamp exists and is recent
        assert.ok(metadata.timestamp, "Metadata should include timestamp");
        assert.strictEqual(typeof metadata.timestamp, "number", "Timestamp should be a number");
        const timestamp = metadata.timestamp as number;
        const now = Date.now();
        const age = now - timestamp;
        assert.ok(age >= 0 && age < 10_000, `Timestamp should be recent (age: ${age}ms, expected < 10000ms)`);

        // Verify source path exists
        assert.ok(metadata.sourcePath, "Metadata should include sourcePath");
        assert.strictEqual(typeof metadata.sourcePath, "string", "Source path should be a string");
        assert.ok(
            (metadata.sourcePath as string).includes("metadata_script.gml"),
            "Source path should reference the test file"
        );
    });
});
