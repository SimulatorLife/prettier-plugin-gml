import { assertFunction, assertPlainObject } from "../shared/index.js";
import { gmlParserAdapter } from "../parsers/gml-parser-adapter.js";
import { print } from "../printer/print.js";
import { handleComments, printComment } from "../comments/comment-printer.js";
import { identifierCaseOptions } from "gamemaker-language-semantic/identifier-case/options.js";
import { LogicalOperatorsStyle } from "../options/logical-operators-style.js";

const REQUIRED_MANIFEST_KEYS = Object.freeze([
    "gmlParserAdapter",
    "print",
    "handleComments",
    "printComment",
    "identifierCaseOptions",
    "LogicalOperatorsStyle"
]);

function createConcreteDependencyManifest() {
    return {
        gmlParserAdapter,
        print,
        handleComments,
        printComment,
        identifierCaseOptions,
        LogicalOperatorsStyle
    };
}

function normalizeManifest(candidate) {
    const manifest = assertPlainObject(candidate, {
        errorMessage:
            "GML plugin dependency manifests must resolve to an object."
    });

    for (const key of REQUIRED_MANIFEST_KEYS) {
        if (!Object.hasOwn(manifest, key)) {
            throw new TypeError(
                `GML plugin dependency manifests must define ${key}.`
            );
        }
    }

    return Object.freeze({
        gmlParserAdapter: manifest.gmlParserAdapter,
        print: manifest.print,
        handleComments: manifest.handleComments,
        printComment: manifest.printComment,
        identifierCaseOptions: manifest.identifierCaseOptions,
        LogicalOperatorsStyle: manifest.LogicalOperatorsStyle
    });
}

let manifestResolver = () =>
    normalizeManifest(createConcreteDependencyManifest());

let cachedManifest = null;

function resolveManifest() {
    const resolved = manifestResolver();

    // Allow resolvers to return cached objects without re-freezing them by
    // short-circuiting when they provide the previously cached manifest.
    if (resolved === cachedManifest && cachedManifest !== null) {
        return cachedManifest;
    }

    cachedManifest = normalizeManifest(resolved);
    return cachedManifest;
}

/**
 * Return the lazily-normalized dependency manifest for the built-in plugin.
 *
 * The manifest is cached after the first successful normalization so repeat
 * calls remain inexpensive even when custom resolvers delegate back to the
 * default implementation.
 *
 * @returns {Readonly<{
 *     gmlParserAdapter: unknown,
 *     print: unknown,
 *     handleComments: unknown,
 *     printComment: unknown,
 *     identifierCaseOptions: unknown,
 *     LogicalOperatorsStyle: unknown
 * }>} Immutable manifest describing the plugin dependency surface.
 */
export function resolveDefaultGmlPluginComponentDependencyManifest() {
    return resolveManifest();
}

/**
 * Override the factory responsible for building the default dependency manifest.
 *
 * Passing a new resolver clears any cached manifest so the next call to
 * {@link resolveDefaultGmlPluginComponentDependencyManifest} re-runs the
 * supplied logic. The resolver must return an object compatible with the
 * manifest schema and may choose to reuse the previously computed manifest.
 *
 * @param {() => object} resolver Factory that returns a manifest candidate.
 * @returns {ReturnType<typeof resolveDefaultGmlPluginComponentDependencyManifest>} The
 *          normalized manifest produced by the new resolver.
 */
export function setDefaultGmlPluginComponentDependencyManifestResolver(
    resolver
) {
    manifestResolver = assertFunction(resolver, "resolver", {
        errorMessage:
            "GML plugin dependency manifest resolvers must be functions."
    });
    cachedManifest = null;
    return resolveManifest();
}

/**
 * Restore the built-in resolver and discard any manifests produced by custom
 * overrides so subsequent calls match a fresh default configuration.
 *
 * @returns {ReturnType<typeof resolveDefaultGmlPluginComponentDependencyManifest>} The
 *          normalized manifest generated by the default resolver.
 */
export function resetDefaultGmlPluginComponentDependencyManifestResolver() {
    manifestResolver = () =>
        normalizeManifest(createConcreteDependencyManifest());
    cachedManifest = null;
    return resolveManifest();
}
