name: "Auto-publish agent drafts"

on:
  schedule:
    - cron: "*/15 * * * *"
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write

jobs:
  publish_drafts:
    runs-on: ubuntu-latest
    steps:
      - name: Publish eligible draft PRs
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_USER_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prefixes = ['copilot/', 'codex/', 'gemini/', ''qwen/'];
            const isAgentBranch = (ref) => typeof ref === 'string' && prefixes.some((prefix) => ref.startsWith(prefix));
            const allowedAuthors = new Set([
              'copilot',
              'copilot[bot]',
              'github-copilot[bot]',
              'github-copilot-code-assistant[bot]',
              'chatgpt-codex-connector[bot]',
              'copilot-bot',
              'copilot-bot[bot]',
              'codex-bot',
              'codex-bot[bot]',
              'gemini',
              'gemini[bot]',
              'google-gemini[bot]'
            ].map((login) => login.toLowerCase()));

            const { data: authUser } = await github.rest.users.getAuthenticated();
            const reviewerLogin = authUser?.login || '';
            const reviewerLower = reviewerLogin.toLowerCase();

            const requiredReviewers = new Set([
              'henrylkirk',
              'henrykirk',
              reviewerLower
            ].filter(Boolean));

            const prs = await github.paginate(github.rest.pulls.list, {
              owner,
              repo,
              state: 'open',
              per_page: 100,
            });

            if (!Array.isArray(prs) || prs.length === 0) {
              core.info('No open pull requests found.');
              return;
            }

            let publishedCount = 0;
            let approvalCount = 0;

            for (const pr of prs) {
              if (!pr?.draft) {
                continue;
              }

              if (!isAgentBranch(pr.head?.ref)) {
                core.debug(`Skipping draft PR #${pr.number}: head branch ${pr.head?.ref} is not an agent branch.`);
                continue;
              }

              if (!isAgentBranch(pr.base?.ref)) {
                core.debug(`Skipping draft PR #${pr.number}: base branch ${pr.base?.ref} is not an agent branch.`);
                continue;
              }

              const headRepoFull = pr.head?.repo?.full_name?.toLowerCase() || '';
              const baseRepoFull = pr.base?.repo?.full_name?.toLowerCase() || '';
              const thisRepoFull = `${owner}/${repo}`.toLowerCase();
              if (headRepoFull !== thisRepoFull || baseRepoFull !== thisRepoFull) {
                core.debug(`Skipping draft PR #${pr.number}: not within ${thisRepoFull}.`);
                continue;
              }

              const files = await github.paginate(github.rest.pulls.listFiles, {
                owner,
                repo,
                pull_number: pr.number,
                per_page: 100,
              });

              const hasChanges = Array.isArray(files) && files.some((file) => Boolean(file?.filename));

              if (!hasChanges) {
                core.info(`Skipping draft PR #${pr.number}: no file changes detected.`);
                continue;
              }

              const authorLogin = pr.user?.login?.toLowerCase() || '';
              if (!allowedAuthors.has(authorLogin)) {
                core.info(`Skipping draft PR #${pr.number}: author ${pr.user?.login} is not an approved agent.`);
                continue;
              }

              const requestedReviewers = Array.isArray(pr.requested_reviewers) ? pr.requested_reviewers : [];
              const hasRequiredReviewer = requestedReviewers.some((reviewer) => {
                const login = reviewer?.login?.toLowerCase() || '';
                return requiredReviewers.has(login);
              });

              if (!hasRequiredReviewer) {
                core.info(`Skipping draft PR #${pr.number}: required reviewer is not requested.`);
                continue;
              }

              let published = false;
              try {
                await github.graphql(
                  `mutation($pullRequestId: ID!) {
                    markPullRequestReadyForReview(input: { pullRequestId: $pullRequestId }) {
                      pullRequest { number }
                    }
                  }`,
                  { pullRequestId: pr.node_id }
                );
                publishedCount += 1;
                published = true;
                core.notice(`Published draft PR #${pr.number} (${pr.head?.ref} -> ${pr.base?.ref}).`);
                await new Promise((resolve) => setTimeout(resolve, 500));
              } catch (error) {
                core.warning(`Failed to publish draft PR #${pr.number}: ${error.message}`);
              }

              let currentPr;
              try {
                const { data } = await github.rest.pulls.get({ owner, repo, pull_number: pr.number });
                currentPr = data;
              } catch (error) {
                core.warning(`Unable to refresh PR #${pr.number}: ${error.message}`);
                continue;
              }

              if (currentPr?.draft) {
                core.debug(`PR #${pr.number} remains a draft; skipping approval.`);
                continue;
              }

              if (!isAgentBranch(currentPr.head?.ref) || !isAgentBranch(currentPr.base?.ref)) {
                core.debug(`Skipping approval for PR #${pr.number}: branches no longer match agent prefixes.`);
                continue;
              }

              if (!allowedAuthors.has(currentPr.user?.login?.toLowerCase() || '')) {
                core.debug(`Skipping approval for PR #${pr.number}: author changed or not an approved agent.`);
                continue;
              }

              const refreshedRequestedReviewers = Array.isArray(currentPr.requested_reviewers) ? currentPr.requested_reviewers : [];
              const stillHasRequiredReviewer = refreshedRequestedReviewers.some((reviewer) => {
                const login = reviewer?.login?.toLowerCase() || '';
                return requiredReviewers.has(login);
              });

              if (!stillHasRequiredReviewer) {
                core.info(`Skipping approval for PR #${pr.number}: required reviewer no longer requested.`);
                continue;
              }

              if (!reviewerLower) {
                core.warning('Authenticated user login unavailable; cannot provide approvals.');
                continue;
              }

              const { data: reviews } = await github.rest.pulls.listReviews({
                owner,
                repo,
                pull_number: pr.number,
                per_page: 100,
              });

              const latestSha = currentPr.head?.sha;
              const hasFreshApproval = Array.isArray(reviews)
                && reviews.some((review) => review.user?.login?.toLowerCase() === reviewerLower
                  && review.state === 'APPROVED'
                  && review.commit_id === latestSha);

              if (hasFreshApproval) {
                core.debug(`PR #${pr.number} already has an approval from ${reviewerLogin} on the latest commit.`);
                continue;
              }

              try {
                await github.rest.pulls.createReview({
                  owner,
                  repo,
                  pull_number: pr.number,
                  event: 'APPROVE',
                });
                approvalCount += 1;
                core.notice(`Approved PR #${pr.number} as ${reviewerLogin}.`);
              } catch (error) {
                core.warning(`Failed to approve PR #${pr.number}: ${error.message}`);
              }
            }

            if (publishedCount === 0) {
              core.info('No draft PRs were published in this run.');
            } else {
              core.notice(`Published ${publishedCount} draft PR(s).`);
            }

            if (approvalCount === 0) {
              core.info('No approvals were recorded in this run.');
            } else {
              core.notice(`Recorded ${approvalCount} approval(s).`);
            }
