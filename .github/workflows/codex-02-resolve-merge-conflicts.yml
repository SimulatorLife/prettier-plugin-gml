name: Codex â€“ Resolve Merge Conflicts

on:
  schedule:
    - cron: "10 * * * *"
  workflow_dispatch:
    inputs:
      target_pr_number:
        description: "Optional PR number to target for conflict resolution."
        required: false
        default: ""

permissions:
  contents: write
  pull-requests: write
  issues: write

concurrency:
  group: codex-resolve-merge-conflicts
  cancel-in-progress: false

jobs:
  resolve_conflicts_comment:
    runs-on: ubuntu-latest
    outputs:
      pr_number: ${{ steps.select_pr.outputs.pr_number }}
      commented: ${{ steps.comment.outputs.commented }}
      manual_run: ${{ steps.select_pr.outputs.manual_run }}
      allow_repeat: ${{ steps.select_pr.outputs.allow_repeat }}

    steps:
      - name: Validate GH_USER_TOKEN
        run: |
          set -e
          test -n "${GH_USER_TOKEN}" || { echo "GH_USER_TOKEN is empty"; exit 1; }
          code=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: token ${GH_USER_TOKEN}" https://api.github.com/user)
          if [ "$code" != "200" ]; then
            echo "Token cannot access /user (HTTP $code). Check scopes, repo access, and SSO."; exit 1;
          fi
        env:
          GH_USER_TOKEN: ${{ secrets.GH_USER_TOKEN }}

      - name: Select PR needing conflict resolution
        id: select_pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_USER_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const marker = "<!-- codex-resolve-merge-conflicts -->";
            const manualInputRaw = context.payload?.inputs?.target_pr_number ?? "";
            const manualInput = typeof manualInputRaw === "string" ? manualInputRaw.trim() : "";
            const manualRun = manualInput.length > 0;

            function setOutputs({
              found,
              prNumber = "",
              headRef = "",
              baseRef = "",
              headSha = "",
              mergeableState = "",
              allowRepeat = false,
            }) {
              core.setOutput("manual_run", manualRun ? "true" : "false");
              core.setOutput("allow_repeat", allowRepeat ? "true" : "false");
              core.setOutput("found", found ? "true" : "false");
              core.setOutput("pr_number", prNumber);
              core.setOutput("head_ref", headRef);
              core.setOutput("base_ref", baseRef);
              core.setOutput("head_sha", headSha);
              core.setOutput("mergeable_state", mergeableState);
            }

            async function fetchPullRequest(prNumber, attempts = 6) {
              for (let attempt = 0; attempt < attempts; attempt++) {
                const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
                if (pr.mergeable !== null) {
                  return pr;
                }
                await new Promise((resolve) => setTimeout(resolve, 2000));
              }
              const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
              return pr;
            }

            async function hasExistingMarker(prNumber) {
              const comments = await github.paginate(
                github.rest.issues.listComments,
                { owner, repo, issue_number: prNumber, per_page: 100 }
              );
              return comments.some((comment) => comment.body && comment.body.includes(marker));
            }

            if (manualRun) {
              const requestedNumber = Number.parseInt(manualInput, 10);
              if (!Number.isInteger(requestedNumber) || requestedNumber <= 0) {
                core.warning(`Invalid target PR number provided: "${manualInput}".`);
                setOutputs({ found: false });
                return;
              }

              const pr = await fetchPullRequest(requestedNumber);
              if (!pr) {
                core.warning(`PR #${requestedNumber} could not be retrieved.`);
                setOutputs({ found: false });
                return;
              }

              if (pr.state !== "open") {
                core.info(`PR #${requestedNumber} is not open (state: ${pr.state}).`);
                setOutputs({ found: false });
                return;
              }

              if ((pr.changed_files || 0) === 0) {
                core.info(`PR #${requestedNumber} has no file changes.`);
                setOutputs({ found: false });
                return;
              }

              const mergeableState = pr.mergeable_state || "unknown";
              if (mergeableState !== "dirty") {
                core.info(`PR #${requestedNumber} is mergeable_state="${mergeableState}".`);
                setOutputs({ found: false });
                return;
              }

              const hadExistingMarker = await hasExistingMarker(pr.number);
              if (hadExistingMarker) {
                core.info(
                  `A conflict resolution request already exists on PR #${requestedNumber}, but manual override will request another comment.`
                );
              }

              core.info(`Using manually specified PR #${requestedNumber} (${pr.head.ref}).`);
              setOutputs({
                found: true,
                prNumber: String(pr.number),
                headRef: pr.head.ref,
                baseRef: pr.base.ref,
                headSha: pr.head.sha,
                mergeableState,
                allowRepeat: hadExistingMarker,
              });
              return;
            }

            async function findCandidate() {
              const openPulls = await github.paginate(
                github.rest.pulls.list,
                { owner, repo, state: "open", sort: "updated", direction: "asc", per_page: 100 }
              );

              for (const summary of openPulls) {
                const pr = await fetchPullRequest(summary.number);
                if (!pr) continue;
                if (pr.state !== "open") continue;
                if (pr.draft) continue;
                if ((pr.changed_files || 0) === 0) continue;
                const mergeableState = pr.mergeable_state || "unknown";
                if (mergeableState !== "dirty") continue;
                if (await hasExistingMarker(pr.number)) continue;

                return pr;
              }

              return null;
            }

            const candidate = await findCandidate();

            if (!candidate) {
              core.info("No eligible PR found for conflict resolution comment.");
              setOutputs({ found: false });
              return;
            }

            core.info(`Selected PR #${candidate.number} (${candidate.head.ref}) for conflict resolution comment.`);
            setOutputs({
              found: true,
              prNumber: String(candidate.number),
              headRef: candidate.head.ref,
              baseRef: candidate.base.ref,
              headSha: candidate.head.sha,
              mergeableState: candidate.mergeable_state || "unknown",
            });

      - name: Comment to request conflict resolution (as your user)
        id: comment
        uses: actions/github-script@v7
        env:
          FOUND: ${{ steps.select_pr.outputs.found }}
          PR_NUMBER: ${{ steps.select_pr.outputs.pr_number }}
          HEAD_REF: ${{ steps.select_pr.outputs.head_ref }}
          BASE_REF: ${{ steps.select_pr.outputs.base_ref }}
          HEAD_SHA: ${{ steps.select_pr.outputs.head_sha }}
          MERGEABLE_STATE: ${{ steps.select_pr.outputs.mergeable_state }}
          MANUAL_RUN: ${{ steps.select_pr.outputs.manual_run }}
          ALLOW_REPEAT: ${{ steps.select_pr.outputs.allow_repeat }}
        with:
          github-token: ${{ secrets.GH_USER_TOKEN }}
          script: |
            if (process.env.FOUND !== "true") {
              core.info("No eligible PR selected; skipping comment.");
              core.setOutput("commented", "false");
              return;
            }

            const prNumber = Number(process.env.PR_NUMBER);
            if (!prNumber) {
              core.warning("Selected PR number is missing; skipping comment.");
              core.setOutput("commented", "false");
              return;
            }

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const marker = "<!-- codex-resolve-merge-conflicts -->";

            async function fetchPullRequest(attempts = 6) {
              for (let attempt = 0; attempt < attempts; attempt++) {
                const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
                if (pr.mergeable !== null) {
                  return pr;
                }
                await new Promise((resolve) => setTimeout(resolve, 2000));
              }
              const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
              return pr;
            }

            const pr = await fetchPullRequest();

            if (!pr) {
              core.warning(`PR #${prNumber} could not be retrieved.`);
              core.setOutput("commented", "false");
              return;
            }

            if (pr.state !== "open") {
              core.info(`PR #${prNumber} is not open (state: ${pr.state}). Skipping comment.`);
              core.setOutput("commented", "false");
              return;
            }

            if (pr.changed_files === 0) {
              core.info(`PR #${prNumber} has no file changes. Skipping comment.`);
              core.setOutput("commented", "false");
              return;
            }

            const mergeableState = pr.mergeable_state || "unknown";
            if (mergeableState !== "dirty") {
              core.info(`PR #${prNumber} is mergeable_state="${mergeableState}". Skipping comment.`);
              core.setOutput("commented", "false");
              return;
            }

            const comments = await github.paginate(
              github.rest.issues.listComments,
              { owner, repo, issue_number: prNumber, per_page: 100 }
            );

            const alreadyCommented = comments.some((comment) => comment.body && comment.body.includes(marker));
            const manualRun = process.env.MANUAL_RUN === "true";
            const allowRepeat = process.env.ALLOW_REPEAT === "true";

            if (alreadyCommented && !(manualRun && allowRepeat)) {
              core.info(`A conflict resolution request already exists on PR #${prNumber}.`);
              core.setOutput("commented", "false");
              return;
            }

            if (alreadyCommented && manualRun && allowRepeat) {
              core.info(`Manual run requested another conflict resolution comment on PR #${prNumber}.`);
            }

            const lines = [
              marker,
              "",
              `@codex This PR currently has merge conflicts between \`${pr.head.ref}\` and \`${pr.base.ref}\`. Please resolve them and push the fixes back to this branch with the smallest possible diff.`,
              "",
              "Follow these steps:",
              "1. Identify the remote that points at this repository (`git remote -v` shows it; call it `<remote>`), then fetch:",
              "```bash",
              "git -c credential.helper= \\",
              "    -c 'credential.helper=store --file .git/codex-cred' \\",
              "    fetch <remote>",
              "```",
              `2. Normalize formatter/lint configuration so both branches share the same tooling baseline:`,
              "   - Create a disposable worktree for the base branch and run the formatters there:",
              "```bash",
              "git -c credential.helper= \\",
              "    -c 'credential.helper=store --file .git/codex-cred' \\",
              "    worktree add ../base-format <remote>/${pr.base.ref}",
              "(cd ../base-format && npm ci && npm run format && npm run lint -- --fix)",
              "```",
              "   - Copy the authoritative formatter/lint configs onto the PR branch (adjust the file list as needed):",
              "```bash",
              "git checkout <remote>/${pr.base.ref} -- eslint.config.js \".prettier*\" .editorconfig",
              "```",
              "   - Run the same normalization passes on the PR branch and stage only mechanical changes:",
              "```bash",
              "npm ci",
              "npm run format",
              "npm run lint -- --fix",
              "git status --short",
              "```",
              "   - Remove the disposable base worktree when finished: `git worktree remove ../base-format`.",
              `3. Check out the PR branch so it tracks the remote tip (use \`git switch ${pr.head.ref}\`, or \`git switch --track <remote>/${pr.head.ref}\` if it is new locally). Abort if \`git status --short\` shows unexpected files.`,
              `4. Inspect what currently differs from \`${pr.base.ref}\` and keep scope tight: \`git diff --stat <remote>/${pr.base.ref}...HEAD\`.`,
              `5. Merge the base without auto-committing so you can review carefully: \`git merge --no-commit --no-ff <remote>/${pr.base.ref}\` (or rebase if required by project policy).`,
              "6. Resolve only the conflicted sections. Avoid touching unrelated code paths.",
              "7. Stage files incrementally, verify `git diff` to ensure only intentional edits remain, then complete the merge commit (or `git rebase --continue`).",
              "8. Run the relevant tests. Afterwards confirm the diff is still narrow: `git diff --stat <remote>/${pr.base.ref}...HEAD` should only list conflict files.",
              "9. Fetch once more and ensure the branch stays cleanly mergeable (`git fetch <remote>` then `git merge --ff-only <remote>/${pr.base.ref}` should say \"Already up to date\").",
              "10. Push your updates using the exact commands below so credentials and remotes are configured correctly:",
              "",
              "```bash",
              `git config user.name  "codex-bot"`,
              `git config user.email "codex@example.com"`,
              `git -c credential.helper= \\`,
              `    -c 'credential.helper=store --file .git/codex-cred' \\`,
              `    push "https://henrylkirk@github.com/${owner}/${repo}.git" "HEAD:${pr.head.ref}"`,
              "Additional context for this task:",
              "```yaml",
              "codex_task:",
              `  branch: "${pr.head.ref}"`,
              `  pr_number: ${pr.number}`,
              `  base: "${pr.base.ref}"`,
              `  head_sha: "${pr.head.sha}"`,
              `  mergeable_state: "${mergeableState}"`,
            ];

            lines.push("```");

            const body = lines.join("\n");

            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: prNumber,
              body,
            });

            core.info(`Posted conflict resolution request to PR #${prNumber}.`);
            core.setOutput("commented", "true");
