name: Auto-merge Codex PRs

on:
  pull_request:
    types: [opened, reopened, synchronize, ready_for_review]
    branches: [main, master]
  push:
    branches:
      - codex/**
      - chore/auto-lint-format
  schedule:
    - cron: "0,30 * * * *"
  workflow_dispatch:
    inputs:
      confirm:
        description: "Type 'merge' to run the auto-merge sweep"
        required: false
        default: "merge"

permissions:
  contents: write
  pull-requests: write

# Avoid overlapping runs per PR
concurrency:
  group: codex-automerge-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: false

jobs:
  request-review:
    if: ${{ startsWith(github.event_name, 'pull_request') || startsWith(github.ref, 'refs/heads/codex/') || github.ref == 'refs/heads/chore/auto-lint-format' }}
    runs-on: ubuntu-latest

    steps:
      - name: Resolve PR number
        id: prnum
        uses: actions/github-script@v7
        with:
          script: |
            let number = null;
            if (context.eventName === 'pull_request') {
              number = context.payload.pull_request.number;
            } else {
              const branch = context.ref.replace('refs/heads/','');
              const { data: prs } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                head: `${context.repo.owner}:${branch}`
              });
              number = prs.length ? prs[0].number : null;
            }
            if (!number) { core.setOutput('skip','true'); return; }
            core.setOutput('skip','false');
            core.setOutput('number', String(number));

      - name: Read PR
        if: ${{ steps.prnum.outputs.skip != 'true' }}
        id: read
        uses: actions/github-script@v7
        with:
          script: |
            const n = Number('${{ steps.prnum.outputs.number }}');
            const timeoutMs = 15 * 60 * 1000; // allow up to 15 minutes for checks to settle
            const pollDelayMs = 10000;
            const deadline = Date.now() + timeoutMs;

            const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

            let pr;

            while (true) {
              const { data } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: n
              });
              pr = data;

              // GitHub may report mergeable=null until background mergeability checks finish.
              if (pr.mergeable === null) {
                if (Date.now() >= deadline) {
                  core.notice(`Bail: mergeability never resolved for PR #${n}.`);
                  core.setOutput('bail', 'true');
                  return;
                }
                await sleep(5000);
                continue;
              }

              const state = (pr.mergeable_state || 'unknown').toLowerCase();

              if (!pr.mergeable && state === 'blocked') {
                const sha = pr.head.sha;

                const combined = await github.rest.repos.getCombinedStatusForRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: sha
                });

                const pendingStatuses = combined.statuses
                  .filter(status => status.state === 'pending')
                  .map(status => status.context);

                const failingStatuses = combined.statuses
                  .filter(status => status.state === 'failure' || status.state === 'error')
                  .map(status => status.context);

                const { data: checkRunsData } = await github.rest.checks.listForRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: sha,
                  per_page: 100
                });

                const pendingChecks = checkRunsData.check_runs
                  .filter(run => run.status !== 'completed')
                  .map(run => run.name);

                const failingChecks = checkRunsData.check_runs
                  .filter(run => run.status === 'completed' && ['failure', 'cancelled', 'timed_out', 'action_required', 'stale'].includes((run.conclusion || '').toLowerCase()))
                  .map(run => run.name);

                if (failingStatuses.length || failingChecks.length) {
                  core.notice(`Bail: failing checks detected (${[...failingStatuses, ...failingChecks].join(', ') || 'unknown'}).`);
                  core.setOutput('bail', 'true');
                  return;
                }

                if ((pendingStatuses.length || pendingChecks.length) && Date.now() < deadline) {
                  core.info(`Pending checks (${[...pendingStatuses, ...pendingChecks].join(', ')}) for PR #${n}; waiting to retry.`);
                  await sleep(pollDelayMs);
                  continue;
                }
              }

              break;
            }

            // Bail early if nothing to merge yet (seed PR)
            const hasRealChanges = (pr.changed_files || 0) > 0;
            if (!hasRealChanges) {
              core.notice(`Bail: no real changes yet (commits=${pr.commits}, files=${pr.changed_files}).`);
              core.setOutput('bail', 'true');
              return;
            }

            const mergeable = !!pr.mergeable;
            const state = (pr.mergeable_state || 'unknown').toLowerCase();
            const draft = !!pr.draft;

            core.setOutput('bail', 'false');
            core.setOutput('mergeable', mergeable ? 'true' : 'false');
            core.setOutput('state', state);
            core.setOutput('draft', draft ? 'true' : 'false');
            core.setOutput('head_ref', pr.head.ref);
            core.setOutput('head_repo_full_name', pr.head.repo?.full_name || '');
            core.setOutput('number', String(n));

      # Temporarily disable Codex review requests while we auto-merge clean PRs.
      # - name: Check for existing Codex review request
      #   if: ${{ steps.read.outputs.bail == 'false' }}
      #   id: review_requested
      #   uses: actions/github-script@v7
      #   with:
      #     script: |
      #       const n = Number('${{ steps.read.outputs.number }}');
      #       const marker = '@codex review the changes in this PR...';
      #       const { data: comments } = await github.rest.issues.listComments({
      #         owner: context.repo.owner,
      #         repo: context.repo.repo,
      #         issue_number: n,
      #         per_page: 100,
      #       });
      #
      #       const alreadyRequested = comments.some(comment => (comment.body || '').trim().startsWith(marker));
      #       core.setOutput('exists', alreadyRequested ? 'true' : 'false');

      # - name: Request Codex review
      #   if: ${{ steps.read.outputs.bail == 'false' && steps.review_requested.outputs.exists != 'true' }}
      #   uses: actions/github-script@v7
      #   with:
      #     github-token: ${{ secrets.GH_USER_TOKEN }}
      #     script: |
      #       const n = Number('${{ steps.read.outputs.number }}');
      #       const body = `@codex review the changes in this PR... take a comprehensive pass.\n\nPlease evaluate the update with high expectations and call out anything that needs attention, including:\n- Simulation performance impacts (grid updates, rendering throughput, memory footprint).\n- Code style, clarity, and maintainability concerns.\n- Compliance with the Simulation Laws and any related safeguards.\n- Test coverage, automation signals, and documentation accuracy.\n- Risks to user experience, accessibility, or stability.\n\nProvide actionable feedback or explicit approval so we can proceed confidently.`;
      #
      #       await github.rest.issues.createComment({
      #         owner: context.repo.owner,
      #         repo: context.repo.repo,
      #         issue_number: n,
      #         body,
      #       });

      - name: Auto-merge PR when ready
        if: ${{ steps.read.outputs.bail == 'false' && steps.read.outputs.mergeable == 'true' && steps.read.outputs.draft != 'true' }}
        uses: actions/github-script@v7
        with:
          script: |
            const n = Number('${{ steps.read.outputs.number }}');
            const state = '${{ steps.read.outputs.state }}'.toLowerCase();
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const headRef = '${{ steps.read.outputs.head_ref }}'.trim();
            const headRepoFullName = '${{ steps.read.outputs.head_repo_full_name }}'.trim();
            const protectedBranches = new Set(['main', 'master']);

            const deleteMergedBranch = async () => {
              if (!headRef) {
                core.info(`Skipping branch cleanup for PR #${n}: no head ref available.`);
                return;
              }

              if (headRepoFullName !== `${owner}/${repo}`) {
                core.info(`Skipping branch cleanup for PR #${n}: head '${headRef}' is not in ${owner}/${repo}.`);
                return;
              }

              if (protectedBranches.has(headRef)) {
                core.info(`Skipping branch cleanup for PR #${n}: '${headRef}' is a protected branch name.`);
                return;
              }

              let branch;
              try {
                const response = await github.rest.repos.getBranch({ owner, repo, branch: headRef });
                branch = response.data;
              } catch (error) {
                if (error.status === 404) {
                  core.info(`Branch '${headRef}' not found; nothing to delete.`);
                } else {
                  core.warning(`Unable to check protection for branch '${headRef}': ${error.message}`);
                }
                return;
              }

              if (branch.protected) {
                core.info(`Skipping branch cleanup for PR #${n}: '${headRef}' is protected.`);
                return;
              }

              try {
                await github.rest.git.deleteRef({ owner, repo, ref: `heads/${headRef}` });
                core.notice(`Deleted branch '${headRef}' after merging PR #${n}.`);
              } catch (error) {
                if (error.status === 422) {
                  core.info(`Branch '${headRef}' could not be deleted (possibly already removed or protected).`);
                } else {
                  core.warning(`Failed to delete branch '${headRef}': ${error.message}`);
                }
              }
            };

            if (!['clean', 'unstable'].includes(state)) {
              core.notice(`Skipping auto-merge for PR #${n} because mergeable_state=${state}.`);
              return;
            }

            try {
              await github.rest.pulls.merge({
                owner,
                repo,
                pull_number: n,
                merge_method: 'squash'
              });
              core.notice(`Auto-merged PR #${n}.`);
              await deleteMergedBranch();
            } catch (error) {
              core.warning(`Auto-merge failed for PR #${n}: ${error.message}`);
              throw error;
            }

  scheduled-automerge:
    if: ${{ github.event_name == 'schedule' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest

    steps:
      - name: Merge eligible open PRs
        uses: actions/github-script@v7
        with:
          script: |
            const trigger = context.eventName;
            if (
              trigger === 'workflow_dispatch' &&
              (context.payload.inputs?.confirm || '').trim().toLowerCase() !== 'merge'
            ) {
              core.notice('Skipping auto-merge sweep: confirmation keyword not provided.');
              return;
            }

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const merged = [];
            const skipped = [];
            const protectedBranches = new Set(['main', 'master']);

            const deleteMergedBranch = async (branchName, headRepoFullName, prNumber) => {
              const ref = (branchName || '').trim();
              if (!ref) {
                core.info(`Skipping branch cleanup for PR #${prNumber}: no head ref available.`);
                return;
              }

              if ((headRepoFullName || '').trim() !== `${owner}/${repo}`) {
                core.info(`Skipping branch cleanup for PR #${prNumber}: head '${ref}' is not in ${owner}/${repo}.`);
                return;
              }

              if (protectedBranches.has(ref)) {
                core.info(`Skipping branch cleanup for PR #${prNumber}: '${ref}' is a protected branch name.`);
                return;
              }

              let branch;
              try {
                const response = await github.rest.repos.getBranch({ owner, repo, branch: ref });
                branch = response.data;
              } catch (error) {
                if (error.status === 404) {
                  core.info(`Branch '${ref}' not found; nothing to delete.`);
                } else {
                  core.warning(`Unable to check protection for branch '${ref}': ${error.message}`);
                }
                return;
              }

              if (branch.protected) {
                core.info(`Skipping branch cleanup for PR #${prNumber}: '${ref}' is protected.`);
                return;
              }

              try {
                await github.rest.git.deleteRef({ owner, repo, ref: `heads/${ref}` });
                core.notice(`Deleted branch '${ref}' after merging PR #${prNumber}.`);
              } catch (error) {
                if (error.status === 422) {
                  core.info(`Branch '${ref}' could not be deleted (possibly already removed or protected).`);
                } else {
                  core.warning(`Failed to delete branch '${ref}': ${error.message}`);
                }
              }
            };

            const openPRs = await github.paginate(
              github.rest.pulls.list,
              { owner, repo, state: 'open', per_page: 100, sort: 'updated', direction: 'desc' }
            );

            const acceptableStates = new Set(['clean', 'unstable']);

            for (const pr of openPRs) {
              if (pr.draft) {
                skipped.push({ number: pr.number, reason: 'draft' });
                continue;
              }

              try {
                const details = await github.rest.pulls.get({ owner, repo, pull_number: pr.number });
                const data = details.data;
                const headRef = data.head?.ref || '';
                const headRepoFullName = data.head?.repo?.full_name || '';

                if ((data.changed_files || 0) === 0) {
                  skipped.push({ number: pr.number, reason: 'no changes' });
                  continue;
                }

                if (data.mergeable === null) {
                  skipped.push({ number: pr.number, reason: 'mergeability unknown' });
                  continue;
                }

                if (!data.mergeable) {
                  skipped.push({ number: pr.number, reason: `mergeable=false (${data.mergeable_state})` });
                  continue;
                }

                const state = (data.mergeable_state || '').toLowerCase();
                if (!acceptableStates.has(state)) {
                  skipped.push({ number: pr.number, reason: `state=${state}` });
                  continue;
                }

                await github.rest.pulls.merge({
                  owner,
                  repo,
                  pull_number: pr.number,
                  merge_method: 'squash'
                });
                await deleteMergedBranch(headRef, headRepoFullName, pr.number);
                merged.push(pr.number);
              } catch (error) {
                core.warning(`Failed to auto-merge PR #${pr.number}: ${error.message}`);
                skipped.push({ number: pr.number, reason: 'exception' });
              }
            }

            core.notice(`Scheduled auto-merge complete. Merged ${merged.length} PR(s): ${merged.join(', ') || 'none'}.`);
            if (skipped.length) {
              const breakdown = skipped
                .map(entry => `#${entry.number} (${entry.reason})`)
                .join(', ');
              core.info(`Skipped PRs: ${breakdown}`);
            }
