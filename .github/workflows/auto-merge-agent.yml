name: Auto merge agent/copilot branches

on:
  workflow_run:
    workflows:
      - Auto-approve Copilot workflow runs
    types:
      - completed
  workflow_dispatch:
    inputs:
      pull_number:
        description: "Pull request number to attempt auto-merge"
        required: true
        type: number

permissions:
  contents: write
  pull-requests: write

jobs:
  auto-merge:
    runs-on: ubuntu-latest
    steps:
      - name: Attempt auto-merge
        uses: actions/github-script@v7
        env:
          DISPATCH_PULL_NUMBER: ${{ inputs.pull_number || '' }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const repoContext = context.repo;
            const owner = repoContext.owner;
            const repo = repoContext.repo;
            const eventName = context.eventName;

            let pull_number = null;

            if (eventName === 'workflow_dispatch') {
              const dispatched = process.env.DISPATCH_PULL_NUMBER;
              if (dispatched) {
                pull_number = Number(dispatched);
              }
            } else if (eventName === 'workflow_run') {
              const run = context.payload.workflow_run;
              if (!run) {
                core.info('No workflow_run payload; skipping auto-merge.');
                return;
              }

              if (run.conclusion && run.conclusion !== 'success') {
                core.info(`Upstream workflow concluded with status ${run.conclusion}; skipping auto-merge.`);
                return;
              }

              if (run.event !== 'pull_request_target') {
                core.info(`Upstream workflow run event ${run.event} is not pull_request_target; skipping.`);
                return;
              }

              const prInfo = Array.isArray(run.pull_requests) ? run.pull_requests[0] : null;
              if (!prInfo?.number) {
                core.info('No pull request associated with workflow_run; skipping auto-merge.');
                return;
              }

              pull_number = prInfo.number;
            }

            if (!pull_number) {
              core.info('Unable to determine pull request number; skipping auto-merge.');
              return;
            }

            const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number });

            if (pr.state !== 'open') {
              core.info(`PR #${pull_number} is ${pr.state}; skipping auto-merge.`);
              return;
            }

            if (pr.draft) {
              core.info(`PR #${pull_number} is still a draft; skipping auto-merge.`);
              return;
            }

            const repoFull = `${owner}/${repo}`.toLowerCase();
            const headRepoFull = pr.head?.repo?.full_name?.toLowerCase() || '';
            const baseRepoFull = pr.base?.repo?.full_name?.toLowerCase() || '';
            if (headRepoFull !== repoFull || baseRepoFull !== repoFull) {
              core.info('PR is not from this repository; skipping auto-merge.');
              return;
            }

            const prefixes = ['agent/', 'copilot/'];
            const hasAllowedPrefix = (ref) => typeof ref === 'string' && prefixes.some((prefix) => ref.startsWith(prefix));
            if (!hasAllowedPrefix(pr.head?.ref) || !hasAllowedPrefix(pr.base?.ref)) {
              core.info('Branch prefixes do not match auto-merge policy; skipping.');
              return;
            }

            function sleep(ms) {
              return new Promise(function (resolve) {
                setTimeout(resolve, ms);
              });
            }
            let attempt = 0;
            let current;
            const maxAttempts = 10;
            const delayMs = 2000;

            while (attempt < maxAttempts) {
              const pull = await github.rest.pulls.get({ owner, repo, pull_number });
              current = pull.data;
              if (current.mergeable !== null) {
                break;
              }
              attempt += 1;
              core.info(
                'Mergeable state pending (attempt ' +
                  attempt +
                  '/' +
                  maxAttempts +
                  '). Retrying...'
              );
              await sleep(delayMs);
            }

            if (!current) {
              core.info('Unable to retrieve pull request details.');
              return;
            }

            if (current.state !== 'open') {
              core.info('PR #' + pull_number + ' is no longer open.');
              return;
            }

            if (current.draft) {
              core.info('PR #' + pull_number + ' is still a draft; skipping merge.');
              return;
            }

            if (!Number.isFinite(current.changed_files) || current.changed_files <= 0) {
              core.info('PR #' + pull_number + ' has no changed files; skipping merge.');
              return;
            }

            if (current.mergeable === null) {
              core.info('Mergeability could not be determined.');
              return;
            }

            if (current.mergeable !== true) {
              core.info(
                'PR #' + pull_number + ' is not mergeable (state: ' + current.mergeable_state + ').'
              );
            }
            await github.rest.pulls.merge({
              owner,
              repo,
              pull_number,
              merge_method: 'merge'
            });
            core.info('Merged PR #' + pull_number + '.');

            // Delete head branch if safe
            try {
              const headRef = pr.head?.ref;
              const headRepoFull = pr.head?.repo?.full_name?.toLowerCase() || '';
              const thisFull = `${owner}/${repo}`.toLowerCase();
              if (!headRef || headRepoFull !== thisFull) {
                core.info(`Not deleting branch: different repo or missing ref (head=${headRepoFull}, this=${thisFull}, ref=${headRef}).`);
              } else {
                const { data: rinfo } = await github.rest.repos.get({ owner, repo });
                const defaultBranch = rinfo.default_branch;
                if (headRef === defaultBranch) {
                  core.info(`Not deleting branch: ${headRef} is the default branch.`);
                } else {
                  await github.rest.git.deleteRef({ owner, repo, ref: `heads/${headRef}` });
                  core.notice(`Deleted branch ${headRef} after merge.`);
                }
              }
            } catch (e) {
              core.warning(`Unable to delete head branch: ${e.message}`);
            }
