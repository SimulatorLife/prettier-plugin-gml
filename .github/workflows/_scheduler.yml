name: "scheduler"

on:
  schedule:
    - cron: "0 */1 * * *" # Every 1 hour
  workflow_dispatch:

permissions:
  contents: write
  actions: write

jobs:
  plan-and-dispatch:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Load workflow configuration
        id: cfg
        run: |
          if [ ! -f .github/workflows/weights.json ]; then
            echo "Configuration file .github/workflows/weights.json is missing" >&2
            exit 1
          fi
          echo "cfg=$(jq -c . .github/workflows/weights.json)" >> "$GITHUB_OUTPUT"

      - name: Compute dispatch plan
        id: plan
        uses: actions/github-script@v7
        env:
          CFG_JSON: ${{ steps.cfg.outputs.cfg }}
        with:
          script: |
            const crypto = require('crypto');

            const cfgRaw = process.env.CFG_JSON;
            const cfg = cfgRaw ? JSON.parse(cfgRaw) : {};
            const workflows = Array.isArray(cfg.workflows) ? cfg.workflows : [];

            const candidates = [];

            for (const workflow of workflows) {
              if (!workflow || typeof workflow.name !== 'string') {
                continue;
              }

              const workflowName = workflow.name;
              const workflowFileName = workflowName.endsWith('.yml') ? workflowName : `${workflowName}.yml`;
              const workflowPath = workflowFileName.startsWith('.github/workflows/')
                ? workflowFileName
                : `.github/workflows/${workflowFileName}`;

              const weightValue = Number(workflow.weight);
              if (!Number.isFinite(weightValue) || weightValue <= 0) {
                core.warning(`Skipping workflow ${workflowPath} due to invalid weight.`);
                continue;
              }
              candidates.push({
                name: workflowName,
                path: workflowPath,
                weight: weightValue,
                topic: workflow.topic ?? null,
              });
            }

            if (candidates.length === 0) {
              core.info('No eligible workflows in configuration.');
              return null;
            }

            const totalWeight = candidates.reduce((sum, item) => sum + item.weight, 0);
            if (!Number.isFinite(totalWeight) || totalWeight <= 0) {
              core.info('Aggregate weight of eligible workflows is zero; nothing to schedule.');
              return null;
            }

            const randomBytes = crypto.randomBytes(6);
            const random = parseInt(randomBytes.toString('hex'), 16) / 0xFFFFFFFFFFFF;
            let threshold = random * totalWeight;
            let cumulative = 0;
            let selected = null;
            for (const workflow of candidates) {
              cumulative += workflow.weight;
              if (threshold <= cumulative) {
                selected = workflow;
                break;
              }
            }

            if (!selected) {
              selected = candidates[candidates.length - 1];
            }

            const baseDir = '.github/workflows/';
            const workflowId = selected.path.startsWith(baseDir)
              ? selected.path.slice(baseDir.length)
              : selected.path;

            core.info(`Selected workflow ${selected.path} (weight=${selected.weight}) from total weight ${totalWeight.toFixed(6)} with draw ${random.toFixed(6)}.`);

            return {
              workflow_name: selected.name,
              workflow_path: selected.path,
              workflow_id: workflowId,
              random_draw: random.toFixed(6),
              total_weight: totalWeight.toFixed(6),
            };

      - name: Dispatch workflow
        if: ${{ steps.plan.outputs.result != '' }}
        uses: actions/github-script@v7
        env:
          PLAN_RESULT: ${{ steps.plan.outputs.result }}
        with:
          github-token: ${{ github.token }}
          script: |
            const raw = process.env.PLAN_RESULT || '';
            const plan = raw ? JSON.parse(raw) : null;

            const workflowId = plan?.workflow_id;
            const workflowPath = plan?.workflow_path || workflowId;

            if (!workflowId) {
              core.info('No workflow selected for dispatch.');
              return;
            }

            let ref = context.ref;
            if (!ref) {
              const { data } = await github.rest.repos.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
              });
              ref = data?.default_branch;
            }

            if (!ref) {
              throw new Error('Unable to determine reference for workflow dispatch.');
            }

            if (ref.startsWith('refs/heads/')) {
              ref = ref.replace('refs/heads/', '');
            } else if (ref.startsWith('refs/tags/')) {
              ref = ref.replace('refs/tags/', '');
            }

            try {
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: workflowId,
                ref,
              });
              core.info(`Dispatched ${workflowPath} via workflow_dispatch on ref ${ref}`);
            } catch (error) {
              core.warning(`Failed to dispatch ${workflowPath}: ${error.message}`);
            }

