name: scheduler

on:
  schedule:
    - cron: "*/5 * * * *" # Every 5 minutes
  workflow_dispatch:

permissions:
  contents: write
  actions: write

jobs:
  plan-and-dispatch:
    runs-on: ubuntu-latest
    env:
      SCHEDULER_RUN_COUNT: '0'
      SCHEDULER_CHOSEN_JSON: '[]'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Load workflow configuration
        id: cfg
        run: |
          if [ ! -f .github/workflows/weights.json ]; then
            echo "Configuration file .github/workflows/weights.json is missing" >&2
            exit 1
          fi
          echo "cfg=$(jq -c . .github/workflows/weights.json)" >> "$GITHUB_OUTPUT"

      - name: Compute dispatch plan
        id: plan
        uses: actions/github-script@v7
        env:
          CFG_JSON: ${{ steps.cfg.outputs.cfg }}
        with:
          script: |
            const crypto = require('crypto');
            const core = require('@actions/core');

            const cfgRaw = process.env.CFG_JSON;
            const cfg = cfgRaw ? JSON.parse(cfgRaw) : {};
            const workflows = Array.isArray(cfg.workflows) ? cfg.workflows : [];
            const now = Date.now();

            const owner = context.repo.owner;
            const repo = context.repo.repo;

            async function getRepoVariable(name) {
              try {
                const { data } = await github.rest.actions.getRepoVariable({ owner, repo, name });
                return data?.value ?? null;
              } catch (error) {
                if (error.status === 404) {
                  return null;
                }
                core.warning(`Failed to read repository variable "${name}": ${error.message}`);
                return null;
              }
            }

            const [quotaEnv, minIntervalMinutesEnv] = await Promise.all([
              getRepoVariable('QUOTA_PER_HOUR'),
              getRepoVariable('SCHEDULER_MIN_INTERVAL_MINUTES'),
            ]);

            const quota = Number.isFinite(Number(quotaEnv)) && Number(quotaEnv) >= 0 ? Number(quotaEnv) : 12;
            const minIntervalMinutes = Number.isFinite(Number(minIntervalMinutesEnv)) && Number(minIntervalMinutesEnv) > 0
              ? Number(minIntervalMinutesEnv)
              : 1;
            const tickMinutes = 5;

            const tickMs = tickMinutes * 60 * 1000;
            const perTickBudget = quota * (tickMinutes / 60);
            const windowKey = Math.floor(now / tickMs);
            const minIntervalMs = minIntervalMinutes * 60 * 1000;

            core.exportVariable('SCHEDULER_CHOSEN_JSON', '[]');
            core.exportVariable('SCHEDULER_RUN_COUNT', '0');

            if (!Number.isFinite(perTickBudget) || perTickBudget <= 0) {
              core.info(`Per-tick budget (${perTickBudget}) is not positive; skipping dispatch.`);
              core.setOutput('chosen_json', '[]');
              core.setOutput('run_count', '0');
              return;
            }

            const eligible = [];
            let newestRunTs = null;

            for (const workflow of workflows) {
              if (!workflow || typeof workflow.name !== 'string') {
                continue;
              }

              const workflowName = workflow.name;
              const workflowFileName = workflowName.endsWith('.yml') ? workflowName : `${workflowName}.yml`;
              const workflowPath = workflowFileName.startsWith('.github/workflows/')
                ? workflowFileName
                : `.github/workflows/${workflowFileName}`;

              const weightValue = Number(workflow.weight);
              if (!Number.isFinite(weightValue) || weightValue <= 0) {
                core.warning(`Skipping workflow ${workflowPath} due to invalid weight.`);
                continue;
              }

              let lastRunTs = null;
              try {
                const { data } = await github.rest.actions.listWorkflowRuns({
                  owner,
                  repo,
                  workflow_id: workflowPath,
                  per_page: 1
                });
                const run = data.workflow_runs?.[0];
                if (run) {
                  const ts = run.run_started_at || run.created_at || run.updated_at;
                  if (ts) {
                    const parsed = Date.parse(ts);
                    if (Number.isFinite(parsed)) {
                      lastRunTs = parsed;
                    }
                  }
                }
              } catch (error) {
                core.warning(`Failed to query runs for ${workflowPath}: ${error.message}`);
              }

              if (lastRunTs && (!newestRunTs || lastRunTs > newestRunTs)) {
                newestRunTs = lastRunTs;
              }

              if (lastRunTs && now - lastRunTs < minIntervalMs) {
                continue;
              }

              eligible.push({
                name: workflowName,
                path: workflowPath,
                weight: weightValue,
                topic: workflow.topic ?? null
              });
            }

            if (eligible.length === 0) {
              core.info('No workflows eligible this tick.');
              core.setOutput('chosen_json', '[]');
              core.setOutput('run_count', '0');
              core.exportVariable('SCHEDULER_CHOSEN_JSON', '[]');
              core.exportVariable('SCHEDULER_RUN_COUNT', '0');
              return;
            }

            if (newestRunTs && now - newestRunTs < minIntervalMs) {
              const minutesRemaining = ((minIntervalMs - (now - newestRunTs)) / 60000).toFixed(1);
              core.info(`Global cooldown active for another ~${minutesRemaining} minutes; skipping dispatch.`);
              core.setOutput('chosen_json', '[]');
              core.setOutput('run_count', '0');
              core.exportVariable('SCHEDULER_CHOSEN_JSON', '[]');
              core.exportVariable('SCHEDULER_RUN_COUNT', '0');
              return;
            }

            const totalWeight = eligible.reduce((sum, item) => sum + item.weight, 0);
            if (!Number.isFinite(totalWeight) || totalWeight <= 0) {
              core.info('Aggregate weight of eligible workflows is zero; nothing to schedule.');
              core.setOutput('chosen_json', '[]');
              core.setOutput('run_count', '0');
              core.exportVariable('SCHEDULER_CHOSEN_JSON', '[]');
              core.exportVariable('SCHEDULER_RUN_COUNT', '0');
              return;
            }

            const desiredPerTickTotal = totalWeight * (tickMinutes / 60);
            const effectiveBudget = Math.min(perTickBudget, desiredPerTickTotal);
            if (!Number.isFinite(effectiveBudget) || effectiveBudget <= 0) {
              core.info('Effective per-tick budget is not positive after normalisation; skipping dispatch.');
              core.setOutput('chosen_json', '[]');
              core.setOutput('run_count', '0');
              core.exportVariable('SCHEDULER_CHOSEN_JSON', '[]');
              core.exportVariable('SCHEDULER_RUN_COUNT', '0');
              return;
            }

            const chosen = [];
            for (const workflow of eligible) {
              const probability = Math.min(1, (workflow.weight / totalWeight) * effectiveBudget);
              const hash = crypto.createHash('sha256')
                .update(`${workflow.path}:${windowKey}`)
                .digest('hex');
              const rand = parseInt(hash.substring(0, 8), 16) / 0xFFFFFFFF;
              if (rand < probability) {
                chosen.push({ name: workflow.name, path: workflow.path, topic: workflow.topic });
              }
            }

            core.info(`Eligible workflows: ${eligible.length}`);
            core.info(`Selected workflows: ${chosen.length}`);
            core.setOutput('chosen_json', JSON.stringify(chosen));
            core.setOutput('run_count', String(chosen.length));
            core.exportVariable('SCHEDULER_CHOSEN_JSON', JSON.stringify(chosen));
            core.exportVariable('SCHEDULER_RUN_COUNT', String(chosen.length));

      - name: Dispatch workflows
        if: ${{ env.SCHEDULER_RUN_COUNT != '' && env.SCHEDULER_RUN_COUNT != '0' }}
        uses: actions/github-script@v7
        env:
          CHOSEN_JSON: ${{ env.SCHEDULER_CHOSEN_JSON || '[]' }}
        with:
          github-token: ${{ github.token }}
          script: |
            const core = require('@actions/core');
            const path = require('path');

            const chosen = JSON.parse(process.env.CHOSEN_JSON || '[]');
            if (!Array.isArray(chosen) || chosen.length === 0) {
              core.info('No workflows selected for dispatch.');
              return;
            }

            let ref = context.ref;
            if (!ref) {
              const { data } = await github.rest.repos.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
              });
              ref = data?.default_branch;
            }

            if (!ref) {
              throw new Error('Unable to determine reference for workflow dispatch.');
            }

            if (ref.startsWith('refs/heads/')) {
              ref = ref.replace('refs/heads/', '');
            } else if (ref.startsWith('refs/tags/')) {
              ref = ref.replace('refs/tags/', '');
            }

            for (const workflow of chosen) {
              const workflowPath = workflow.path || (workflow.name?.endsWith('.yml') ? workflow.name : `${workflow.name}.yml`);
              const workflowId = workflowPath.startsWith('.github/workflows/')
                ? workflowPath.slice('.github/workflows/'.length)
                : path.basename(workflowPath);

              try {
                await github.rest.actions.createWorkflowDispatch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: workflowId,
                  ref,
                });
                core.info(`Dispatched ${workflowPath} via workflow_dispatch on ref ${ref}`);
              } catch (error) {
                core.warning(`Failed to dispatch ${workflowPath}: ${error.message}`);
              }
            }

