name: scheduler

on:
  schedule:
    - cron: "*/45 * * * *" # Every 45 minutes
  workflow_dispatch:

permissions:
  contents: write
  actions: write

jobs:
  plan-and-dispatch:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Load workflow configuration
        id: cfg
        run: |
          if [ ! -f .github/workflows/weights.json ]; then
            echo "Configuration file .github/workflows/weights.json is missing" >&2
            exit 1
          fi
          echo "cfg=$(jq -c . .github/workflows/weights.json)" >> "$GITHUB_OUTPUT"

      - name: Compute dispatch plan
        id: plan
        uses: actions/github-script@v7
        env:
          CFG_JSON: ${{ steps.cfg.outputs.cfg }}
        with:
          script: |
            const crypto = require('crypto');
            const fs = require('fs');
            const path = require('path');

            const cfgRaw = process.env.CFG_JSON;
            const cfg = cfgRaw ? JSON.parse(cfgRaw) : {};
            const workflows = Array.isArray(cfg.workflows) ? cfg.workflows : [];

            const normalize = (value) => {
              const trimmed = (value || '').trim();
              if (!trimmed) return '';
              return trimmed
                .toLowerCase()
                .replace(/[^a-z0-9]+/g, '-')
                .replace(/^-+|-+$/g, '')
                || '';
            };

            const chooseWeighted = (items) => {
              const total = items.reduce((sum, item) => sum + item.weight, 0);
              if (!Number.isFinite(total) || total <= 0) {
                return null;
              }

              const random = parseInt(crypto.randomBytes(6).toString('hex'), 16) / 0xFFFFFFFFFFFF;
              let threshold = random * total;
              for (const item of items) {
                threshold -= item.weight;
                if (threshold <= 0) {
                  return { item, random, total };
                }
              }

              return { item: items[items.length - 1], random, total };
            };

            const candidates = [];

            for (const workflow of workflows) {
              if (!workflow || typeof workflow.name !== 'string') {
                continue;
              }

              const workflowName = workflow.name;
              const workflowFileName = workflowName.endsWith('.yml') ? workflowName : `${workflowName}.yml`;
              const workflowPath = workflowFileName.startsWith('.github/workflows/')
                ? workflowFileName
                : `.github/workflows/${workflowFileName}`;

              const weightValue = Number(workflow.weight);
              if (!Number.isFinite(weightValue) || weightValue <= 0) {
                core.warning(`Skipping workflow ${workflowPath} due to invalid weight.`);
                continue;
              }
              candidates.push({
                name: workflowName,
                path: workflowPath,
                weight: weightValue,
                topic: workflow.topic ?? null,
              });
            }

            if (candidates.length === 0) {
              core.info('No eligible workflows in configuration.');
              return null;
            }

            const totalWeight = candidates.reduce((sum, item) => sum + item.weight, 0);
            if (!Number.isFinite(totalWeight) || totalWeight <= 0) {
              core.info('Aggregate weight of eligible workflows is zero; nothing to schedule.');
              return null;
            }

            const randomBytes = crypto.randomBytes(6);
            const random = parseInt(randomBytes.toString('hex'), 16) / 0xFFFFFFFFFFFF;
            let threshold = random * totalWeight;
            let cumulative = 0;
            let selected = null;
            for (const workflow of candidates) {
              cumulative += workflow.weight;
              if (threshold <= cumulative) {
                selected = workflow;
                break;
              }
            }

            if (!selected) {
              selected = candidates[candidates.length - 1];
            }

            const baseDir = '.github/workflows/';
            const workflowId = selected.path.startsWith(baseDir)
              ? selected.path.slice(baseDir.length)
              : selected.path;

            core.info(`Selected workflow ${selected.path} (weight=${selected.weight}) from total weight ${totalWeight.toFixed(6)} with draw ${random.toFixed(6)}.`);

            let agentSelection = null;
            try {
              const weightsPath = path.resolve(process.cwd(), '.github/workflows/weights.json');
              const raw = fs.readFileSync(weightsPath, 'utf8');
              const parsed = JSON.parse(raw);
              if (Array.isArray(parsed?.agents)) {
                const agentCandidates = parsed.agents
                  .map((agent) => ({
                    name: typeof agent?.name === 'string' ? agent.name : '',
                    weight: Number(agent?.weight),
                  }))
                  .filter((agent) => agent.name && Number.isFinite(agent.weight) && agent.weight > 0)
                  .map((agent) => ({
                    ...agent,
                    slug: normalize(agent.name),
                  }))
                  .filter((agent) => agent.slug);

                if (agentCandidates.length) {
                  agentSelection = chooseWeighted(agentCandidates);
                }
              }
            } catch (error) {
              core.warning(`Unable to load agent weights: ${error.message}`);
            }

            let agentSlug = 'copilot';
            let agentName = 'copilot';
            let agentWeight = '';
            if (agentSelection?.item) {
              agentSlug = agentSelection.item.slug;
              agentName = agentSelection.item.name;
              agentWeight = `${agentSelection.item.weight}`;
              core.info(`Selected agent ${agentName} (slug=${agentSlug}, weight=${agentSelection.item.weight}) with draw ${agentSelection.random.toFixed(6)} from total weight ${agentSelection.total.toFixed(6)}.`);
            } else {
              core.info('Defaulting to agent "copilot" (no valid weighted agent configuration found).');
            }

            return {
              workflow_name: selected.name,
              workflow_path: selected.path,
              workflow_id: workflowId,
              random_draw: random.toFixed(6),
              total_weight: totalWeight.toFixed(6),
              agent: agentSlug,
              agent_name: agentName,
              agent_weight: agentWeight,
            };

      - name: Dispatch workflow
        if: ${{ steps.plan.outputs.result != '' }}
        uses: actions/github-script@v7
        env:
          PLAN_RESULT: ${{ steps.plan.outputs.result }}
        with:
          github-token: ${{ github.token }}
          script: |
            const raw = process.env.PLAN_RESULT || '';
            const plan = raw ? JSON.parse(raw) : null;

            const workflowId = plan?.workflow_id;
            const workflowPath = plan?.workflow_path || workflowId;
            const agent = plan?.agent;

            if (!workflowId) {
              core.info('No workflow selected for dispatch.');
              return;
            }

            let ref = context.ref;
            if (!ref) {
              const { data } = await github.rest.repos.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
              });
              ref = data?.default_branch;
            }

            if (!ref) {
              throw new Error('Unable to determine reference for workflow dispatch.');
            }

            if (ref.startsWith('refs/heads/')) {
              ref = ref.replace('refs/heads/', '');
            } else if (ref.startsWith('refs/tags/')) {
              ref = ref.replace('refs/tags/', '');
            }

            try {
              const inputs = {};
              if (agent) {
                inputs.agent = agent;
              }

              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: workflowId,
                ref,
                inputs: Object.keys(inputs).length ? inputs : undefined,
              });
              core.info(`Dispatched ${workflowPath} via workflow_dispatch on ref ${ref}${agent ? ` (agent=${agent})` : ''}`);
            } catch (error) {
              core.warning(`Failed to dispatch ${workflowPath}: ${error.message}`);
            }

