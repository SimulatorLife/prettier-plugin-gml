name: Auto-merge PRs

on:
  pull_request:
    types: [opened, reopened, synchronize, ready_for_review]
    branches: [main, master, mainline]
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  checks: write

concurrency:
  group: automerge-${{ github.event.pull_request.number || 'manual' }}
  cancel-in-progress: true

jobs:
  tests:
    name: Run tests (${{ matrix.target }})
    runs-on: ubuntu-latest
    timeout-minutes: 30
    strategy:
      fail-fast: false
      matrix:
        target: [base, head, merge]

    steps:
      - name: Check if PR has any changed files
        id: changed
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const number = context.payload.pull_request?.number;
            if (!number) { core.setOutput('skip','false'); return; }
            const files = await github.paginate(github.rest.pulls.listFiles, { owner, repo, pull_number: number, per_page: 100 });
            const count = files.length;
            core.notice(`PR changed files: ${count}`);
            core.setOutput('skip', count === 0 ? 'true' : 'false');

      - name: Stop early if no files changed
        if: steps.changed.outputs.skip == 'true'
        run: |
          echo "No changed files in this PR — skipping test jobs."
          exit 0

      - name: Resolve ref for ${{ matrix.target }}
        id: ref
        run: |
          if [ "${{ matrix.target }}" = "base" ]; then
            echo "ref=${{ github.event.pull_request.base.sha }}" >> "$GITHUB_OUTPUT"
          elif [ "${{ matrix.target }}" = "head" ]; then
            echo "ref=${{ github.sha }}" >> "$GITHUB_OUTPUT"
          else
            echo "ref=refs/pull/${{ github.event.pull_request.number }}/merge" >> "$GITHUB_OUTPUT"
          fi

      # If the synthetic merge ref doesn't exist, continue so the leg can still upload nothing and be summarized.
      - name: Checkout (${{ matrix.target }})
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.ref.outputs.ref }}
        continue-on-error: ${{ matrix.target == 'merge' }}

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install deps
        run: npm ci
        continue-on-error: ${{ matrix.target == 'merge' }}

      # Your npm script should create ./test-results/*.xml and NOT hard-exit early
      - name: Run test suite (JUnit XML)
        run: npm run test:report
        continue-on-error: true

      - name: Publish PR test summary (${{ matrix.target }})
        if: ${{ always() }}
        uses: dorny/test-reporter@v2
        with:
          name: Node.js test results (${{ matrix.target }})
          path: test-results/*.xml
          reporter: java-junit
          fail-on-error: false
          fail-on-empty: false
          use-actions-summary: false

      - name: Upload JUnit artifacts (${{ matrix.target }})
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: junit-${{ matrix.target }}
          path: test-results/*.xml
          retention-days: 7

  summarize:
    name: Summarize & comment table
    needs: tests
    runs-on: ubuntu-latest
    outputs:
      all_green: ${{ steps.regress.outputs.all_green }}
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: junit-*
          merge-multiple: false

      # Use your repo’s logic to compute regressions (allows legacy failures)
      - name: Detect regressions (repo script)
        id: regress
        run: |
          set +e
          export BASE_RESULTS_DIR="$(pwd)/junit-base"
          export MERGE_RESULTS_DIR="$(pwd)/junit-merge"
          # Falls back to head when merge isn't available (handled by your script)
          node src/cli/commands/detect-test-regressions.mjs
          code=$?
          if [ $code -eq 0 ]; then
            echo "all_green=true" >> "$GITHUB_OUTPUT"
          else
            echo "all_green=false" >> "$GITHUB_OUTPUT"
          fi
          exit 0

      - name: Summarize and comment
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('node:fs');
            const path = require('node:path');

            const MARKER = '<!-- automerge-pr-test-summary -->';
            const targets = ['base','head','merge'];
            const totals = {};
            const notes = [];

            function readSuites(dir) {
              const xmlFiles = fs.existsSync(dir) ? fs.readdirSync(dir).filter(f => f.endsWith('.xml')).map(f => path.join(dir,f)) : [];
              let t = { tests:0, failures:0, errors:0, skipped:0, time:0 };
              for (const file of xmlFiles) {
                const xml = fs.readFileSync(file,'utf8');
                const suiteAttrs = [...xml.matchAll(/<testsuite\b([^>]*)>/g)];
                for (const m of suiteAttrs) {
                  const a = m[1] || '';
                  const pick = k => (a.match(new RegExp(`${k}="([^"]*)"`)) || [])[1] ?? null;
                  const n = v => (v === null ? 0 : Number.parseFloat(v)) || 0;
                  t.tests    += n(pick('tests'));
                  t.failures += n(pick('failures'));
                  t.errors   += n(pick('errors'));
                  t.skipped  += n(pick('skipped'));
                  t.time     += n(pick('time'));
                }
              }
              return t;
            }

            for (const tgt of targets) {
              const dir = path.join(process.cwd(), `junit-${tgt}`);
              totals[tgt] = readSuites(dir);
              if (!fs.existsSync(dir)) notes.push(`No JUnit XML found for **${tgt}**.`);
            }

            const fmtTime = s => !Number.isFinite(s) || s <= 0 ? '—'
              : s < 1 ? `${(s*1000).toFixed(0)}ms`
              : s >= 60 ? `${Math.floor(s/60)}m ${(s - Math.floor(s/60)*60).toFixed(1)}s`
              : `${s.toFixed(2)}s`;

            const row = (label, t) => {
              const hasAny = (t.tests + t.failures + t.errors + t.skipped) > 0;
              if (!hasAny) return `| ${label} | — | — | — | — | — |`;
              const failed = t.failures + t.errors;
              const passed = Math.max(0, t.tests - failed - t.skipped);
              return `| ${label} | ${t.tests} | ${passed} | ${failed} | ${t.skipped} | ${fmtTime(t.time)} |`;
            };

            const baseRef = context.payload.pull_request?.base?.ref || 'base';
            const baseSha = (context.payload.pull_request?.base?.sha || '').slice(0,7) || '???????';
            const headRef = context.payload.pull_request?.head?.ref || 'head';
            const headSha = (context.payload.pull_request?.head?.sha || context.sha || '').slice(0,7) || '???????';

            const table = [
              '| Target | Total | Passed | Failed | Skipped | Duration |',
              '| --- | ---: | ---: | ---: | ---: | ---: |',
              row(`Base (${baseRef} @ ${baseSha})`, totals.base),
              row(`PR (${headRef} @ ${headSha})`, totals.head),
              row('Merged (base+PR)', totals.merge),
              '',
              ...notes.map(n => `> ⚠️ ${n}`)
            ].join('\n');

            const body = [ '<!-- automerge-pr-test-summary -->', '### Node.js regression test summary', '', table ].join('\n');

            const { owner, repo } = context.repo;
            const number = context.payload.pull_request?.number;
            if (!number) { core.notice('No PR number; skipping comment.'); return; }

            const comments = await github.paginate(github.rest.issues.listComments, { owner, repo, issue_number: number, per_page: 100 });
            const existing = comments.find(c => c.body && c.body.includes(MARKER));
            if (existing) {
              await github.rest.issues.updateComment({ owner, repo, comment_id: existing.id, body });
            } else {
              await github.rest.issues.createComment({ owner, repo, issue_number: number, body });
            }

  auto-merge:
    name: Auto-merge when green
    needs: summarize
    if: ${{ github.event_name == 'pull_request' && needs.summarize.outputs.all_green == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Merge PR (and delete branch if safe)
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const number = context.payload.pull_request.number;
            const pr = (await github.rest.pulls.get({ owner, repo, pull_number: number })).data;

            if (pr.draft) { core.notice(`Skip merge #${number}: draft.`); return; }
            const ok = pr.mergeable === true && ['clean','unstable','blocked'].includes(String(pr.mergeable_state).toLowerCase());
            if (!ok) { core.notice(`Skip merge #${number}: mergeable=${pr.mergeable}, state=${pr.mergeable_state}.`); return; }

            await github.rest.pulls.merge({ owner, repo, pull_number: number, merge_method: 'squash' });
            core.notice(`Auto-merged PR #${number}.`);

            // Delete head branch if safe
            try {
              const headRef = pr.head?.ref;
              const headRepoFull = pr.head?.repo?.full_name?.toLowerCase() || '';
              const thisFull = `${owner}/${repo}`.toLowerCase();
              if (!headRef || headRepoFull !== thisFull) {
                core.info(`Not deleting branch: different repo or missing ref (head=${headRepoFull}, this=${thisFull}, ref=${headRef}).`);
              } else {
                const { data: rinfo } = await github.rest.repos.get({ owner, repo });
                const defaultBranch = rinfo.default_branch;
                if (headRef === defaultBranch) {
                  core.info(`Not deleting branch: ${headRef} is the default branch.`);
                } else {
                  await github.rest.git.deleteRef({ owner, repo, ref: `heads/${headRef}` });
                  core.notice(`Deleted branch ${headRef} after merge.`);
                }
              }
            } catch (e) {
              core.warning(`Unable to delete head branch: ${e.message}`);
            }
