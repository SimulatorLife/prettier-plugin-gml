name: "Auto-merge PRs"

on:
  pull_request:
    types: [opened, reopened, synchronize, ready_for_review]
    branches: [main, master, mainline]
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  checks: write

concurrency:
  group: automerge-${{ github.event.pull_request.number || 'manual' }}
  cancel-in-progress: true

jobs:
  gate:
    runs-on: ubuntu-latest
    outputs:
      should_run_tests: ${{ steps.decide.outputs.should_run_tests }}
    steps:
      - id: decide
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const n = context.payload.pull_request?.number;
            if (!n) { core.setOutput('should_run_tests', 'false'); return; }
            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner, repo, pull_number: n, per_page: 100
            });
            core.notice(`PR changed files: ${files.length}`);
            core.setOutput('should_run_tests', files.length > 0 ? 'true' : 'false');

  tests:
    needs: gate
    if: ${{ needs.gate.outputs.should_run_tests == 'true' }}   # <- job-level gate (will show Skipped)
    name: Run tests (${{ matrix.target }})
    runs-on: ubuntu-latest
    timeout-minutes: 30
    strategy:
      fail-fast: false
      matrix:
        target: [base, head, merge]

    steps:
      - name: Resolve ref for ${{ matrix.target }}
        id: ref
        run: |
          if [ "${{ matrix.target }}" = "base" ]; then
            echo "ref=${{ github.event.pull_request.base.sha }}" >> "$GITHUB_OUTPUT"
          elif [ "${{ matrix.target }}" = "head" ]; then
            echo "ref=${{ github.sha }}" >> "$GITHUB_OUTPUT"
          else
            echo "ref=refs/pull/${{ github.event.pull_request.number }}/merge" >> "$GITHUB_OUTPUT"
          fi

      # If the synthetic merge ref doesn't exist, continue so the leg can still upload nothing and be summarized.
      - name: Checkout (${{ matrix.target }})
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.ref.outputs.ref }}
        continue-on-error: ${{ matrix.target == 'merge' }}

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc
          cache: 'npm'

      - name: Install deps
        run: npm ci
        continue-on-error: ${{ matrix.target == 'merge' }}

      # Runs tests once, generating both JUnit XML and LCOV coverage
      - name: Run tests & coverage
        run: npm run test:ci
        continue-on-error: true

      - name: Publish test summary (${{ matrix.target }})
        if: ${{ always() }}
        uses: dorny/test-reporter@v2
        with:
          name: Publish test summary (${{ matrix.target }})
          path: reports/*.xml
          reporter: java-junit
          fail-on-error: false
          fail-on-empty: false
          use-actions-summary: false

      - name: Run lint (checkstyle)
        run: npm run lint:report
        continue-on-error: true

      - name: Verify lint report was generated
        run: |
          if [ ! -f reports/eslint-checkstyle.xml ]; then
            echo "::error::Lint report was not generated. Check if eslint-formatter-checkstyle is installed."
            exit 1
          fi
          echo "::notice::Lint report generated successfully at reports/eslint-checkstyle.xml"

      - name: Run duplicates check
        run: npm run lint:duplicates:report
        continue-on-error: true

      - name: Collect project stats
        run: npm run stats:report
        continue-on-error: true

      - name: Upload JUnit artifacts (${{ matrix.target }})
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: junit-${{ matrix.target }}
          path: |
            reports/*.xml
            reports/lcov.info
            reports/jscpd-report.json
            reports/project-health.json
          retention-days: 7

  summarize:
    name: Summarize & comment table
    needs: tests
    runs-on: ubuntu-latest
    outputs:
      all_green: ${{ steps.summarize.outputs.all_green }}
    env:
      GH_USER_TOKEN: ${{ secrets.GH_USER_TOKEN }}
    steps:
      - name: Checkout repo (for scripts)
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc
          cache: 'npm'

      - name: Install deps
        run: npm ci
      
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: junit-*
          merge-multiple: false

      # Use your repo’s logic to compute regressions (allows legacy failures)
      - name: Detect regressions
        id: regress
        run: |
          set +e
          set -o pipefail
          
          # Create reports directory if it doesn't exist
          mkdir -p reports

          # Run the CLI command with explicit paths to the downloaded artifacts
          npm run cli -- generate-quality-report \
            --base junit-base \
            --head junit-head \
            --merge junit-merge \
            --report-file reports/summary-report.md
          
          code=$?
          
          if [ $code -eq 0 ]; then
            echo "all_green=true" >> "$GITHUB_OUTPUT"
            echo "status=clean" >> "$GITHUB_OUTPUT"
          else
            echo "all_green=false" >> "$GITHUB_OUTPUT"
            echo "status=regressions" >> "$GITHUB_OUTPUT"
          fi
          exit 0

      - name: Summarize and comment
        id: summarize
        uses: actions/github-script@v7
        env:
          REGRESSION_ALL_GREEN: ${{ steps.regress.outputs.all_green }}
          REGRESSION_STATUS: ${{ steps.regress.outputs.status }}
        with:
          script: |
            const fs = require('node:fs');
            const path = require('node:path');

            const MARKER = '<!-- automerge-pr-test-summary -->';
            const reportFile = 'reports/summary-report.md';
            
            let body = '';
            if (fs.existsSync(reportFile)) {
              body = fs.readFileSync(reportFile, 'utf8');
            } else {
              body = `${MARKER}\n### Quality Report Summary\n\n⚠️ Report generation failed. Check the action logs for details.`;
            }

            const { owner, repo } = context.repo;
            const number = context.payload.pull_request?.number;
            if (!number) { core.notice('No PR number; skipping comment.'); return; }

            const comments = await github.paginate(github.rest.issues.listComments, { owner, repo, issue_number: number, per_page: 100 });
            const existing = comments.find(c => c.body && c.body.includes(MARKER));
            if (existing) {
              await github.rest.issues.updateComment({ owner, repo, comment_id: existing.id, body });
            } else {
              await github.rest.issues.createComment({ owner, repo, issue_number: number, body });
            }
            
            // Set output for auto-merge gate
            const allGreen = process.env.REGRESSION_ALL_GREEN === 'true';
            core.setOutput('all_green', allGreen ? 'true' : 'false');

      - name: Request Agent help for regressions
        if: ${{ github.event_name == 'pull_request' && steps.regress.outputs.status == 'regressions' && env.GH_USER_TOKEN != '' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.GH_USER_TOKEN }}
          script: |
            const marker = '<!-- automerge-pr-regression-agent -->';
            const { owner, repo } = context.repo;
            const number = context.payload.pull_request?.number;
            if (!number) {
              core.notice('No PR number; skipping Agent regression comment.');
              return;
            }

            const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: number });
            const branchLower = (pr.head?.ref || '').toLowerCase();
            // Extract the agent prefix (the part before the first '/') and require it to be present
            const rawPrefix = (branchLower.split('/')[0] || '').replace(/^@/, '').trim();
            if (!rawPrefix) {
              core.info('No agent prefix found on branch name; skipping agent regression request.');
              return;
            }
            const agentPrefix = rawPrefix;
            const agentMention = `@${agentPrefix}`;
            const comments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number: number,
              per_page: 100,
            });

            const existing = comments.find(comment => comment.body && comment.body.includes(marker));

            const lines = [
              marker,
              '',
              `${agentMention} The auto-merge workflow detected test regressions on this PR while comparing \`${pr.head.ref}\` against \`${pr.base.ref}\`. Please review the failing suites, identify the root cause, and provide the fixes so this change can be merged.`,
              '',
              'Suggested next steps:',
              '1. Review the "Node.js regression test summary" comment and the uploaded junit-* artifacts for detailed failure reports.',
              '2. Reproduce the failures locally (for example, `npm run test:report` and `npm run test:coverage`) to confirm the regression.',
              '3. Deliver the smallest possible fix—or a precise explanation of the required follow-up—that resolves the regression blocking auto-merge.'
            ];

            const normalizedAgent = agentMention.replace(/^@/, '').trim().toLowerCase();
            if (normalizedAgent !== 'copilot') {
              lines.push(
                '',
                `Once done, ensure all changes are pushed to remote branch **${pr.head.ref}** on base **${pr.base.ref}** and keep all commits tied to PR #${number}; do not open new branches or PRs. As the final step (even after running 'make_pr'), run the following exact command(s) to guarantee your changes are pushed:`,
                '',
                '```bash',
                `git push "https://github.com/${owner}/${repo}.git" "HEAD:${pr.head.ref}"`,
                '```'
              );
            }

            const body = lines.join('\n');

            if (existing) {
              await github.rest.issues.updateComment({ owner, repo, comment_id: existing.id, body });
            } else {
              await github.rest.issues.createComment({ owner, repo, issue_number: number, body });
            }

            core.notice(`Requested Agent assistance for regressions on PR #${number}.`);

      - name: Warn when Agent user token missing
        if: ${{ github.event_name == 'pull_request' && steps.regress.outputs.status == 'regressions' && env.GH_USER_TOKEN == '' }}
        run: |
          echo "::warning::GH_USER_TOKEN secret is not configured; skipping Agent regression comment."

  auto-merge:
    name: Auto-merge when green
    needs: summarize
    if: ${{ github.event_name == 'pull_request' && needs.summarize.outputs.all_green == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Prepare PR & wait for mergeability
        id: prepare
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const number = context.payload.pull_request?.number;
            if (!number) { core.setOutput('proceed', 'false'); return; }
            const loadPr = async () => (await github.rest.pulls.get({ owner, repo, pull_number: number })).data;
            const wait = ms => new Promise(resolve => setTimeout(resolve, ms));

            const allowedStates = new Set(['clean','unstable','blocked','has_hooks']);

            let pr = await loadPr();
            if (pr.draft) { core.notice(`Skip merge #${number}: draft.`); core.setOutput('proceed','false'); return; }

            const maxAttempts = 6;
            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
              const state = String(pr.mergeable_state || '').toLowerCase();
              const mergeableKnown = pr.mergeable !== null && state && state !== 'unknown';
              if (mergeableKnown) break;

              if (attempt === maxAttempts) {
                core.notice(`Skip merge #${number}: mergeability unresolved after ${maxAttempts} attempts (mergeable=${pr.mergeable}, state=${pr.mergeable_state}).`);
                core.setOutput('proceed','false');
                return;
              }

              core.info(`Mergeability pending for #${number} (attempt ${attempt}/${maxAttempts}): mergeable=${pr.mergeable}, state=${pr.mergeable_state}. Retrying in 5s...`);
              await wait(5000);
              pr = await loadPr();
            }

            const state = String(pr.mergeable_state || '').toLowerCase();
            const ok = pr.mergeable === true && allowedStates.has(state);
            if (!ok) { core.notice(`Skip merge #${number}: mergeable=${pr.mergeable}, state=${pr.mergeable_state}.`); core.setOutput('proceed','false'); return; }

            core.setOutput('proceed','true');
            core.setOutput('pr', JSON.stringify(pr));

      - name: Update PR branch from base (attempt updateBranch, fallback to server-side merge)
        id: update
        if: ${{ steps.prepare.outputs.proceed == 'true' }}
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const number = context.payload.pull_request.number;
            const pr = JSON.parse(process.env.PREPARE_PR || '{}');
            const wait = ms => new Promise(resolve => setTimeout(resolve, ms));
            const MARKER = '<!-- automerge-branch-update -->';

            const upsert = async (text) => {
              try {
                const comments = await github.paginate(github.rest.issues.listComments, { owner, repo, issue_number: number, per_page: 100 });
                const existing = comments.find(c => c.body && c.body.includes(MARKER));
                const body = [MARKER, text].join('\n\n');
                if (existing) {
                  await github.rest.issues.updateComment({ owner, repo, comment_id: existing.id, body });
                } else {
                  await github.rest.issues.createComment({ owner, repo, issue_number: number, body });
                }
              } catch (err) {
                core.warning(`Failed to upsert branch-update comment: ${err?.message || err}`);
              }
            };

            await upsert('Auto-merge preparing: ensuring PR branch is up-to-date with base branch.');

            try {
              await github.rest.pulls.updateBranch({ owner, repo, pull_number: number });
              await upsert('Requested branch update via GitHub API (pulls.updateBranch). Waiting for the update to apply...');
              core.info('Requested branch update via pulls.updateBranch()');
              await wait(5000);
              core.setOutput('updated','true');
              return;
            } catch (ubErr) {
              core.warning(`pulls.updateBranch failed: ${ubErr?.message || ubErr}`);
              await upsert(`pulls.updateBranch failed: ${ubErr?.message || ubErr}. Attempting fallback server-side merge of base into PR branch.`);
            }

            try {
              const baseRef = pr.base.ref;
              const headRef = pr.head.ref;
              core.info(`Attempting server-side merge of base '${baseRef}' into head '${headRef}' via repos.merge()`);
              await github.rest.repos.merge({ owner, repo, base: headRef, head: baseRef, commit_message: `chore: sync ${headRef} with ${baseRef}` });
              await upsert('Fallback server-side merge performed: base was merged into the PR branch. Waiting for refs to update...');
              await wait(3000);
              core.setOutput('updated','true');
              return;
            } catch (srvErr) {
              core.warning(`Server-side repos.merge fallback failed: ${srvErr?.message || srvErr}`);
              await upsert(`Fallback server-side merge failed: ${srvErr?.message || srvErr}. Manual intervention required.`);
              core.setOutput('updated','false');
              core.setOutput('update_error', String(srvErr?.message || srvErr));
              return;
            }
        env:
          PREPARE_PR: ${{ steps.prepare.outputs.pr }}

      - name: Attempt merge
        id: attempt
        if: ${{ steps.prepare.outputs.proceed == 'true' }}
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const number = context.payload.pull_request.number;
            try {
              await github.rest.pulls.merge({ owner, repo, pull_number: number, merge_method: 'squash' });
              core.notice(`Auto-merged PR #${number}.`);
              core.setOutput('merged','true');
            } catch (e) {
              core.warning(`Merge attempt failed: ${e?.message || e}`);
              core.setOutput('merged','false');
              core.setOutput('merge_error', String(e?.message || ''));
            }

      - name: Delete head branch (if merged)
        if: ${{ steps.attempt.outputs.merged == 'true' }}
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const number = context.payload.pull_request.number;
            const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: number });
            try {
              const headRef = pr.head?.ref;
              const headRepoFull = pr.head?.repo?.full_name?.toLowerCase() || '';
              const thisFull = `${owner}/${repo}`.toLowerCase();
              if (!headRef || headRepoFull !== thisFull) {
                core.info(`Not deleting branch: different repo or missing ref (head=${headRepoFull}, this=${thisFull}, ref=${headRef}).`);
                return;
              }
              const { data: rinfo } = await github.rest.repos.get({ owner, repo });
              const defaultBranch = rinfo.default_branch;
              if (headRef === defaultBranch) {
                core.info(`Not deleting branch: ${headRef} is the default branch.`);
                return;
              }
              await github.rest.git.deleteRef({ owner, repo, ref: `heads/${headRef}` });
              core.notice(`Deleted branch ${headRef} after merge.`);
            } catch (e) {
              core.warning(`Unable to delete head branch: ${e.message}`);
            }
