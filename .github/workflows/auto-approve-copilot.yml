name: Auto-approve Copilot workflow runs

on:
  workflow_run:
    types:
      - requested

permissions:
  actions: write

jobs:
  approve:
    if: >-
      ${{
        github.event.workflow_run.event == 'workflow_dispatch'
        && github.event.workflow_run.path
        && startsWith(github.event.workflow_run.path, '.github/workflows/agent-')
      }}
    runs-on: ubuntu-latest
    steps:
      - name: Approve pending run
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_USER_TOKEN }}
          script: |
            const { workflow_run: run } = context.payload;
            if (!run?.id) {
              core.info('No workflow_run.id; nothing to approve.');
              return;
            }

            await github.request('POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve', {
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: run.id,
            });

            core.notice(`Auto-approved run ${run.id} for workflow "${run.name}" triggered by ${run.actor?.login}.`);

      - name: Approve pull request as maintainer
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_USER_TOKEN }}
          script: |
            const run = context.payload.workflow_run;
            if (!run) {
              core.info('No workflow_run payload; skipping PR approval.');
              return;
            }

            if (run.event !== 'pull_request_target') {
              core.info(`Workflow event ${run.event} is not pull_request_target; skipping PR approval.`);
              return;
            }

            const prInfo = Array.isArray(run.pull_requests) ? run.pull_requests[0] : null;
            if (!prInfo?.number) {
              core.info('No pull request associated with workflow_run; skipping approval.');
              return;
            }

            const { owner, repo } = context.repo;
            const pull_number = prInfo.number;

            const prefixes = ['codex/', 'copilot/'];
            const hasAllowedPrefix = (ref) => typeof ref === 'string' && prefixes.some((prefix) => ref.startsWith(prefix));

            const { data: initialPr } = await github.rest.pulls.get({ owner, repo, pull_number });
            if (initialPr.state !== 'open') {
              core.info(`PR #${pull_number} is ${initialPr.state}; skipping approval.`);
              return;
            }

            const { data: authUser } = await github.rest.users.getAuthenticated();
            const reviewerLogin = authUser?.login;
            if (!reviewerLogin) {
              core.warning('Unable to resolve authenticated user for review approval.');
              return;
            }

            let pr = initialPr;

            try {
              const repoFull = `${owner}/${repo}`.toLowerCase();
              const headRepoFull = pr.head?.repo?.full_name?.toLowerCase() || '';
              const baseRepoFull = pr.base?.repo?.full_name?.toLowerCase() || '';
              const reviewerCount = Array.isArray(pr.requested_reviewers) ? pr.requested_reviewers.length : 0;
              const teamCount = Array.isArray(pr.requested_teams) ? pr.requested_teams.length : 0;
              const totalRequestedReviewers = reviewerCount + teamCount;

              const hasChangedFiles = Number.isFinite(pr.changed_files) && pr.changed_files > 0;
              const eligiblePrefixes = hasAllowedPrefix(pr.head?.ref) && hasAllowedPrefix(pr.base?.ref);
              const sameRepo = headRepoFull === repoFull && baseRepoFull === repoFull;

              if (pr.draft && totalRequestedReviewers > 0 && hasChangedFiles && eligiblePrefixes && sameRepo) {
                await github.graphql(
                  `mutation($pullRequestId: ID!) {
                    markPullRequestReadyForReview(input: { pullRequestId: $pullRequestId }) {
                      pullRequest { number }
                    }
                  }`,
                  { pullRequestId: pr.node_id }
                );
                core.notice(`Marked PR #${pull_number} ready for review after reviewer assignment.`);

                const refreshed = await github.rest.pulls.get({ owner, repo, pull_number });
                pr = refreshed.data;
              }
            } catch (error) {
              core.warning(`Unable to publish PR #${pull_number}: ${error.message}`);
            }

            if (pr.draft) {
              core.info(`PR #${pull_number} remains a draft; skipping approval.`);
              return;
            }

            const { data: reviews } = await github.rest.pulls.listReviews({
              owner,
              repo,
              pull_number,
              per_page: 100,
            });

            const latestSha = pr.head?.sha;
            const hasFreshApproval = Array.isArray(reviews)
              && reviews.some((review) => review.user?.login === reviewerLogin
                && review.state === 'APPROVED'
                && review.commit_id === latestSha);

            if (hasFreshApproval) {
              core.info(`PR #${pull_number} already has an approval from ${reviewerLogin} on the latest commit.`);
              return;
            }

            await github.rest.pulls.createReview({
              owner,
              repo,
              pull_number,
              event: 'APPROVE',
            });

            core.notice(`Approved PR #${pull_number} as ${reviewerLogin}.`);
