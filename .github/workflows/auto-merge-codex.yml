name: Auto merge codex/copilot branches

on:
  pull_request:
    types:
      - opened
      - reopened
      - synchronize
      - ready_for_review

permissions:
  contents: write
  pull-requests: write

jobs:
  auto-merge:
    if: >-
      github.event.action != 'closed' &&
      github.event.pull_request.draft == false
    runs-on: ubuntu-latest
    steps:
      - name: Attempt auto-merge
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            const prefixes = ['codex/', 'copilot/'];

            function hasAllowedPrefix(ref) {
              for (const prefix of prefixes) {
                if (ref.startsWith(prefix)) {
                  return true;
                }
              }
              return false;
            }

            if (!hasAllowedPrefix(pr.head.ref) || !hasAllowedPrefix(pr.base.ref)) {
              core.info(
                'Skipping PR with head ' + pr.head.ref + ' and base ' + pr.base.ref
              );
              return;
            }

            const repoContext = context.repo;
            const owner = repoContext.owner;
            const repo = repoContext.repo;
            const pull_number = pr.number;

            function sleep(ms) {
              return new Promise(function (resolve) {
                setTimeout(resolve, ms);
              });
            }
            let attempt = 0;
            let current;
            const maxAttempts = 10;
            const delayMs = 2000;

            while (attempt < maxAttempts) {
              const pull = await github.rest.pulls.get({ owner, repo, pull_number });
              current = pull.data;
              if (current.mergeable !== null) {
                break;
              }
              attempt += 1;
              core.info(
                'Mergeable state pending (attempt ' +
                  attempt +
                  '/' +
                  maxAttempts +
                  '). Retrying...'
              );
              await sleep(delayMs);
            }

            if (!current) {
              core.info('Unable to retrieve pull request details.');
              return;
            }

            if (current.state !== 'open') {
              core.info('PR #' + pull_number + ' is no longer open.');
              return;
            }

            if (current.mergeable === null) {
              core.info('Mergeability could not be determined.');
              return;
            }

            if (current.mergeable !== true) {
              core.info(
                'PR #' + pull_number + ' is not mergeable (state: ' + current.mergeable_state + ').'
              );
              return;
            }

            await github.rest.pulls.merge({
              owner,
              repo,
              pull_number,
              merge_method: 'merge'
            });
            core.info('Merged PR #' + pull_number + '.');
