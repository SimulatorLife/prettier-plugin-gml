name: Auto merge codex/copilot branches

on:
  pull_request_target:
    types:
      - opened
      - reopened
      - synchronize
      - ready_for_review
      - review_requested

permissions:
  contents: write
  pull-requests: write

jobs:
  auto-merge:
    runs-on: ubuntu-latest
    steps:
      - name: Attempt auto-merge
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            if (!pr) {
              core.info('No pull request in payload; skipping auto-merge.');
              return;
            }

            const repoContext = context.repo;
            const owner = repoContext.owner;
            const repo = repoContext.repo;
            const pull_number = pr.number;

            if (context.payload.action === 'closed') {
              core.info('Pull request event is for a closed PR; skipping auto-merge.');
              return;
            }

            const repoFull = `${owner}/${repo}`.toLowerCase();
            const headRepoFull = pr.head?.repo?.full_name?.toLowerCase() || '';
            const baseRepoFull = pr.base?.repo?.full_name?.toLowerCase() || '';
            if (headRepoFull !== repoFull || baseRepoFull !== repoFull) {
              core.info('PR is not from this repository; skipping auto-merge.');
              return;
            }

            const prefixes = ['codex/', 'copilot/'];
            const hasAllowedPrefix = (ref) => typeof ref === 'string' && prefixes.some((prefix) => ref.startsWith(prefix));
            if (!hasAllowedPrefix(pr.head?.ref) || !hasAllowedPrefix(pr.base?.ref)) {
              core.info('Branch prefixes do not match auto-merge policy; skipping.');
              return;
            }

            function sleep(ms) {
              return new Promise(function (resolve) {
                setTimeout(resolve, ms);
              });
            }
            let attempt = 0;
            let current;
            const maxAttempts = 10;
            const delayMs = 2000;

            while (attempt < maxAttempts) {
              const pull = await github.rest.pulls.get({ owner, repo, pull_number });
              current = pull.data;
              if (current.mergeable !== null) {
                break;
              }
              attempt += 1;
              core.info(
                'Mergeable state pending (attempt ' +
                  attempt +
                  '/' +
                  maxAttempts +
                  '). Retrying...'
              );
              await sleep(delayMs);
            }

            if (!current) {
              core.info('Unable to retrieve pull request details.');
              return;
            }

            if (current.state !== 'open') {
              core.info('PR #' + pull_number + ' is no longer open.');
              return;
            }

            if (current.draft) {
              core.info('PR #' + pull_number + ' is still a draft; skipping merge.');
              return;
            }

            if (!Number.isFinite(current.changed_files) || current.changed_files <= 0) {
              core.info('PR #' + pull_number + ' has no changed files; skipping merge.');
              return;
            }

            if (current.mergeable === null) {
              core.info('Mergeability could not be determined.');
              return;
            }

            if (current.mergeable !== true) {
              core.info(
                'PR #' + pull_number + ' is not mergeable (state: ' + current.mergeable_state + ').'
              );
            }
            await github.rest.pulls.merge({
              owner,
              repo,
              pull_number,
              merge_method: 'merge'
            });
            core.info('Merged PR #' + pull_number + '.');

            // Delete head branch if safe
            try {
              const headRef = pr.head?.ref;
              const headRepoFull = pr.head?.repo?.full_name?.toLowerCase() || '';
              const thisFull = `${owner}/${repo}`.toLowerCase();
              if (!headRef || headRepoFull !== thisFull) {
                core.info(`Not deleting branch: different repo or missing ref (head=${headRepoFull}, this=${thisFull}, ref=${headRef}).`);
              } else {
                const { data: rinfo } = await github.rest.repos.get({ owner, repo });
                const defaultBranch = rinfo.default_branch;
                if (headRef === defaultBranch) {
                  core.info(`Not deleting branch: ${headRef} is the default branch.`);
                } else {
                  await github.rest.git.deleteRef({ owner, repo, ref: `heads/${headRef}` });
                  core.notice(`Deleted branch ${headRef} after merge.`);
                }
              }
            } catch (e) {
              core.warning(`Unable to delete head branch: ${e.message}`);
            }
