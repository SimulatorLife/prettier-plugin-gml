name: Auto merge codex/copilot branches

on:
  pull_request_target:
    types:
      - opened
      - reopened
      - synchronize
      - ready_for_review
      - review_requested

permissions:
  contents: write
  pull-requests: write

jobs:
  publish-codex-pr:
    if: >-
      github.event.action == 'review_requested' ||
      github.event.action == 'rerequested' ||
      github.event.action == 'labeled' ||
      github.event.action == 'synchronize' ||
      github.event.action == 'ready_for_review' ||
      github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    steps:
      - name: Publish codex/copilot draft when review is requested
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            if (!pr) {
              core.info('No pull request payload; skipping publish logic.');
              return;
            }

            const repoFull = `${context.repo.owner}/${context.repo.repo}`.toLowerCase();
            const headRepoFull = pr.head?.repo?.full_name?.toLowerCase() || '';
            if (headRepoFull !== repoFull) {
              core.info(`Skipping publish for forked head ${headRepoFull || '<unknown>'}.`);
              return;
            }

            if (!pr.draft) {
              core.info(`PR #${pr.number} is already ready for review.`);
              return;
            }

            const prefixes = ['codex/', 'copilot/'];
            const hasAllowedPrefix = (ref) =>
              typeof ref === 'string' && prefixes.some((prefix) => ref.startsWith(prefix));

            const headRef = pr.head?.ref || '';
            const baseRef = pr.base?.ref || '';
            if (!hasAllowedPrefix(headRef) || !hasAllowedPrefix(baseRef)) {
              core.info(
                `Skipping publish for head ${headRef || '<unknown>'} and base ${baseRef || '<unknown>'}; prefixes do not match.`
              );
              return;
            }

            const reviewerCount = Array.isArray(pr.requested_reviewers) ? pr.requested_reviewers.length : 0;
            const teamCount = Array.isArray(pr.requested_teams) ? pr.requested_teams.length : 0;
            const totalRequestedReviewers = reviewerCount + teamCount;

            if (totalRequestedReviewers === 0) {
              core.info('No reviewer or team currently requested; skipping publish.');
              return;
            }

            if (!Number.isFinite(pr.changed_files) || pr.changed_files <= 0) {
              core.info(`No changed files detected (${pr.changed_files}); skipping publish.`);
              return;
            }

            await github.graphql(
              `mutation($pullRequestId: ID!) {
                markPullRequestReadyForReview(input: { pullRequestId: $pullRequestId }) {
                  pullRequest {
                    number
                  }
                }
              }`,
              {
                pullRequestId: pr.node_id
              }
            );
            core.notice(`Marked PR #${pr.number} as ready for review after reviewer assignment.`);

  auto-merge:
    runs-on: ubuntu-latest
    steps:
      - name: Attempt auto-merge
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            if (!pr) {
              core.info('No pull request in payload; skipping auto-merge.');
              return;
            }

            const repoContext = context.repo;
            const owner = repoContext.owner;
            const repo = repoContext.repo;
            const pull_number = pr.number;

            if (context.payload.action === 'closed') {
              core.info('Pull request event is for a closed PR; skipping auto-merge.');
              return;
            }

            const repoFull = `${owner}/${repo}`.toLowerCase();
            const headRepoFull = pr.head?.repo?.full_name?.toLowerCase() || '';
            const baseRepoFull = pr.base?.repo?.full_name?.toLowerCase() || '';
            if (headRepoFull !== repoFull || baseRepoFull !== repoFull) {
              core.info('PR is not from this repository; skipping auto-merge.');
              return;
            }

            const prefixes = ['codex/', 'copilot/'];
            const hasAllowedPrefix = (ref) => typeof ref === 'string' && prefixes.some((prefix) => ref.startsWith(prefix));
            if (!hasAllowedPrefix(pr.head?.ref) || !hasAllowedPrefix(pr.base?.ref)) {
              core.info('Branch prefixes do not match auto-merge policy; skipping.');
              return;
            }

            function sleep(ms) {
              return new Promise(function (resolve) {
                setTimeout(resolve, ms);
              });
            }
            let attempt = 0;
            let current;
            const maxAttempts = 10;
            const delayMs = 2000;

            while (attempt < maxAttempts) {
              const pull = await github.rest.pulls.get({ owner, repo, pull_number });
              current = pull.data;
              if (current.mergeable !== null) {
                break;
              }
              attempt += 1;
              core.info(
                'Mergeable state pending (attempt ' +
                  attempt +
                  '/' +
                  maxAttempts +
                  '). Retrying...'
              );
              await sleep(delayMs);
            }

            if (!current) {
              core.info('Unable to retrieve pull request details.');
              return;
            }

            if (current.state !== 'open') {
              core.info('PR #' + pull_number + ' is no longer open.');
              return;
            }

            if (current.draft) {
              core.info('PR #' + pull_number + ' is still a draft; skipping merge.');
              return;
            }

            if (!Number.isFinite(current.changed_files) || current.changed_files <= 0) {
              core.info('PR #' + pull_number + ' has no changed files; skipping merge.');
              return;
            }

            if (current.mergeable === null) {
              core.info('Mergeability could not be determined.');
              return;
            }

            if (current.mergeable !== true) {
              core.info(
                'PR #' + pull_number + ' is not mergeable (state: ' + current.mergeable_state + ').'
              );
            }
            await github.rest.pulls.merge({
              owner,
              repo,
              pull_number,
              merge_method: 'merge'
            });
            core.info('Merged PR #' + pull_number + '.');

            // Delete head branch if safe
            try {
              const headRef = pr.head?.ref;
              const headRepoFull = pr.head?.repo?.full_name?.toLowerCase() || '';
              const thisFull = `${owner}/${repo}`.toLowerCase();
              if (!headRef || headRepoFull !== thisFull) {
                core.info(`Not deleting branch: different repo or missing ref (head=${headRepoFull}, this=${thisFull}, ref=${headRef}).`);
              } else {
                const { data: rinfo } = await github.rest.repos.get({ owner, repo });
                const defaultBranch = rinfo.default_branch;
                if (headRef === defaultBranch) {
                  core.info(`Not deleting branch: ${headRef} is the default branch.`);
                } else {
                  await github.rest.git.deleteRef({ owner, repo, ref: `heads/${headRef}` });
                  core.notice(`Deleted branch ${headRef} after merge.`);
                }
              }
            } catch (e) {
              core.warning(`Unable to delete head branch: ${e.message}`);
            }
