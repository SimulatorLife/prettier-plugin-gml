name: Auto merge codex/copilot branches

on:
  pull_request:
    types:
      - opened
      - reopened
      - synchronize
      - ready_for_review

permissions:
  contents: write
  pull-requests: write

jobs:
  auto-merge:
    if: >-
      github.event.action != 'closed' &&
      github.event.pull_request.draft == false
    runs-on: ubuntu-latest
    steps:
      - name: Determine auto-merge eligibility
        id: eligibility
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            if (!pr) {
              core.setOutput('eligible', 'false');
              core.info('No pull request payload; skipping lint gate.');
              return;
            }

            const prefixes = ['codex/', 'copilot/'];
            const hasAllowedPrefix = (ref) =>
              typeof ref === 'string' && prefixes.some((prefix) => ref.startsWith(prefix));

            const eligible =
              hasAllowedPrefix(pr.head?.ref || '') && hasAllowedPrefix(pr.base?.ref || '');

            core.setOutput('eligible', eligible ? 'true' : 'false');

            if (!eligible) {
              core.info(
                `Skipping lint gate for head ${pr.head?.ref || '<unknown>'} and base ${
                  pr.base?.ref || '<unknown>'
                }`
              );
            }

      - name: Checkout PR head for lint gate
        if: steps.eligibility.outputs.eligible == 'true'
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Setup Node.js
        if: steps.eligibility.outputs.eligible == 'true'
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc
          cache: 'npm'
          cache-dependency-path: |
            package-lock.json
            base/package-lock.json

      - name: Install dependencies (PR head)
        if: steps.eligibility.outputs.eligible == 'true'
        run: npm ci

      - name: Generate lint report (PR head)
        if: steps.eligibility.outputs.eligible == 'true'
        run: npm run lint:report
        continue-on-error: true

      - name: Checkout base for lint comparison
        if: steps.eligibility.outputs.eligible == 'true'
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.base.sha }}
          path: base

      - name: Install dependencies (base)
        if: steps.eligibility.outputs.eligible == 'true'
        run: npm ci
        working-directory: base

      - name: Generate lint report (base)
        if: steps.eligibility.outputs.eligible == 'true'
        run: npm run lint:report
        working-directory: base
        continue-on-error: true

      - name: Check for newly introduced lint errors
        if: steps.eligibility.outputs.eligible == 'true'
        run: |
          node <<'NODE'
          const fs = require('node:fs');
          const path = require('node:path');

          function readLintReport(root, label) {
            const reportPath = path.join(root, 'reports', 'eslint-checkstyle.xml');
            if (!fs.existsSync(reportPath)) {
              console.error(`Lint report not found for ${label} at ${reportPath}`);
              return null;
            }

            const contents = fs.readFileSync(reportPath, 'utf8');
            let errors = 0;
            let warnings = 0;
            const pattern = /<error\b[^>]*severity="([^"]*)"/i;
            for (const match of contents.matchAll(pattern)) {
              const severity = (match[1] || '').toLowerCase();
              if (severity === 'error') {
                errors += 1;
              } else if (severity === 'warning') {
                warnings += 1;
              }
            }

            return { errors, warnings, reportPath };
          }

          const base = readLintReport('base', 'base');
          const head = readLintReport('.', 'PR');

          if (!base || !head) {
            console.error('Unable to compare lint results â€” blocking auto-merge.');
            process.exit(1);
          }

          console.log(`Base lint errors: ${base.errors} (warnings: ${base.warnings})`);
          console.log(`PR lint errors: ${head.errors} (warnings: ${head.warnings})`);

          if (head.errors > base.errors) {
            const delta = head.errors - base.errors;
            console.error(`PR introduces ${delta} new lint error${delta === 1 ? '' : 's'}.`);
            process.exit(1);
          }

          console.log('No newly introduced lint errors detected.');
          NODE

      - name: Attempt auto-merge
        if: steps.eligibility.outputs.eligible == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            const repoContext = context.repo;
            const owner = repoContext.owner;
            const repo = repoContext.repo;
            const pull_number = pr.number;

            function sleep(ms) {
              return new Promise(function (resolve) {
                setTimeout(resolve, ms);
              });
            }
            let attempt = 0;
            let current;
            const maxAttempts = 10;
            const delayMs = 2000;

            while (attempt < maxAttempts) {
              const pull = await github.rest.pulls.get({ owner, repo, pull_number });
              current = pull.data;
              if (current.mergeable !== null) {
                break;
              }
              attempt += 1;
              core.info(
                'Mergeable state pending (attempt ' +
                  attempt +
                  '/' +
                  maxAttempts +
                  '). Retrying...'
              );
              await sleep(delayMs);
            }

            if (!current) {
              core.info('Unable to retrieve pull request details.');
              return;
            }

            if (current.state !== 'open') {
              core.info('PR #' + pull_number + ' is no longer open.');
              return;
            }

            if (current.mergeable === null) {
              core.info('Mergeability could not be determined.');
              return;
            }

            if (current.mergeable !== true) {
              core.info(
                'PR #' + pull_number + ' is not mergeable (state: ' + current.mergeable_state + ').'
              );
              return;
            }

            await github.rest.pulls.merge({
              owner,
              repo,
              pull_number,
              merge_method: 'merge'
            });
            core.info('Merged PR #' + pull_number + '.');

            // Delete head branch if safe
            try {
              const headRef = pr.head?.ref;
              const headRepoFull = pr.head?.repo?.full_name?.toLowerCase() || '';
              const thisFull = `${owner}/${repo}`.toLowerCase();
              if (!headRef || headRepoFull !== thisFull) {
                core.info(`Not deleting branch: different repo or missing ref (head=${headRepoFull}, this=${thisFull}, ref=${headRef}).`);
              } else {
                const { data: rinfo } = await github.rest.repos.get({ owner, repo });
                const defaultBranch = rinfo.default_branch;
                if (headRef === defaultBranch) {
                  core.info(`Not deleting branch: ${headRef} is the default branch.`);
                } else {
                  await github.rest.git.deleteRef({ owner, repo, ref: `heads/${headRef}` });
                  core.notice(`Deleted branch ${headRef} after merge.`);
                }
              }
            } catch (e) {
              core.warning(`Unable to delete head branch: ${e.message}`);
            }
